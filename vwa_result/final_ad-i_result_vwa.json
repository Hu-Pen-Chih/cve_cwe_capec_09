{
    "results": [
        {
            "CVE-ID": "CVE-2011-3374",
            "CVE-Description": "It was found that apt-key in apt, all versions, do not correctly validate gpg keys with the master keyring, leading to a potential man-in-the-middle attack.",
            "Severity": "LOW",
            "Mapped CWE-ID": 295,
            "CWE Description": "The product does not validate, or incorrectly validates, a certificate.",
            "Mapped CAPEC-ID": 209,
            "CAPEC Description": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.",
            "Original CWE-ID": "CWE-347",
            "Original CAPEC-ID": "475, 463"
        },
        {
            "CVE-ID": "CVE-2022-3715",
            "CVE-Description": "A flaw was found in the bash package, where a heap-buffer overflow can occur in valid parameter_transform. This issue may lead to memory problems.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 263,
            "CAPEC Description": "This describes an attack where an application is forced to use a file that an attacker has corrupted. The result is often a denial of service caused by the application being unable to process the corrupted file, but other results, including the disabling of filters or access controls (if the application fails in an unsafe way rather than failing by locking down) or buffer overflows are possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2017-13716",
            "CVE-Description": "The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).",
            "Severity": "LOW",
            "Mapped CWE-ID": 770,
            "CWE Description": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
            "Mapped CAPEC-ID": 130,
            "CAPEC Description": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2018-18483",
            "CVE-Description": "The get_count function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31, allows remote attackers to cause a denial of service (malloc called with the result of an integer-overflowing calculation) or possibly have unspecified other impact via a crafted string, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20673",
            "CVE-Description": "The demangle_template function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31.1, contains an integer overflow vulnerability (for \"Create an array for saving the template argument values\") that can trigger a heap-based buffer overflow, as demonstrated by nm.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20712",
            "CVE-Description": "A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty, as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults, leading to denial-of-service, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2019-1010204",
            "CVE-Description": "GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation, Signed/Unsigned Comparison, Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497, elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2020-35448",
            "CVE-Description": "An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2021-20197",
            "CVE-Description": "There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar, objcopy, strip, ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users), an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.",
            "Severity": "LOW",
            "Mapped CWE-ID": 79,
            "CWE Description": "The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.",
            "Mapped CAPEC-ID": 209,
            "CAPEC Description": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2021-32256",
            "CVE-Description": "An issue was discovered in GNU libiberty, as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-3549",
            "CVE-Description": "An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-45078",
            "CVE-Description": "stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact, as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-46174",
            "CVE-Description": "Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35205",
            "CVE-Description": "An issue was discovered in Binutils readelf 2.38.50, reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 617,
            "CWE Description": "The product contains an assert() or similar statement that can be triggered by an attacker, which leads to an application exit or other behavior that is more severe than necessary.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-617",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35206",
            "CVE-Description": "Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 129,
            "CAPEC Description": "This attack pattern involves an adversary manipulating a pointer within a target application resulting in the application accessing an unintended memory location. This can result in the crashing of the application or, for certain pointer values, access to data that would not normally be possible or the execution of arbitrary code. Since pointers are simply integer variables, Integer Attacks may often be used in Pointer Attacks.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-38533",
            "CVE-Description": "In GNU Binutils before 2.40, there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.",
            "Severity": "LOW",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 263,
            "CAPEC Description": "This describes an attack where an application is forced to use a file that an attacker has corrupted. The result is often a denial of service caused by the application being unable to process the corrupted file, but other results, including the disabling of filters or access controls (if the application fails in an unsafe way rather than failing by locking down) or buffer overflows are possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-4285",
            "CVE-Description": "An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-44840",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-45703",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-47673",
            "CVE-Description": "An issue was discovered in Binutils addr2line before 2.39.3, function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2022-48064",
            "CVE-Description": "GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.",
            "Severity": "LOW",
            "Mapped CWE-ID": 770,
            "CWE Description": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
            "Mapped CAPEC-ID": 130,
            "CAPEC Description": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2023-1579",
            "CVE-Description": "Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-1972",
            "CVE-Description": "A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25584",
            "CVE-Description": "An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2023-25585",
            "CVE-Description": "A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25586",
            "CVE-Description": "A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25588",
            "CVE-Description": "A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function, which may lead to an application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2017-13716",
            "CVE-Description": "The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).",
            "Severity": "LOW",
            "Mapped CWE-ID": 770,
            "CWE Description": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
            "Mapped CAPEC-ID": 130,
            "CAPEC Description": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2018-18483",
            "CVE-Description": "The get_count function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31, allows remote attackers to cause a denial of service (malloc called with the result of an integer-overflowing calculation) or possibly have unspecified other impact via a crafted string, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20673",
            "CVE-Description": "The demangle_template function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31.1, contains an integer overflow vulnerability (for \"Create an array for saving the template argument values\") that can trigger a heap-based buffer overflow, as demonstrated by nm.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20712",
            "CVE-Description": "A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty, as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults, leading to denial-of-service, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2019-1010204",
            "CVE-Description": "GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation, Signed/Unsigned Comparison, Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497, elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2020-35448",
            "CVE-Description": "An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2021-20197",
            "CVE-Description": "There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar, objcopy, strip, ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users), an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.",
            "Severity": "LOW",
            "Mapped CWE-ID": 79,
            "CWE Description": "The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.",
            "Mapped CAPEC-ID": 209,
            "CAPEC Description": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2021-32256",
            "CVE-Description": "An issue was discovered in GNU libiberty, as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-3549",
            "CVE-Description": "An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-45078",
            "CVE-Description": "stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact, as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-46174",
            "CVE-Description": "Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35205",
            "CVE-Description": "An issue was discovered in Binutils readelf 2.38.50, reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 617,
            "CWE Description": "The product contains an assert() or similar statement that can be triggered by an attacker, which leads to an application exit or other behavior that is more severe than necessary.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-617",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35206",
            "CVE-Description": "Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 129,
            "CAPEC Description": "This attack pattern involves an adversary manipulating a pointer within a target application resulting in the application accessing an unintended memory location. This can result in the crashing of the application or, for certain pointer values, access to data that would not normally be possible or the execution of arbitrary code. Since pointers are simply integer variables, Integer Attacks may often be used in Pointer Attacks.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-38533",
            "CVE-Description": "In GNU Binutils before 2.40, there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.",
            "Severity": "LOW",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 263,
            "CAPEC Description": "This describes an attack where an application is forced to use a file that an attacker has corrupted. The result is often a denial of service caused by the application being unable to process the corrupted file, but other results, including the disabling of filters or access controls (if the application fails in an unsafe way rather than failing by locking down) or buffer overflows are possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-4285",
            "CVE-Description": "An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-44840",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-45703",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-47673",
            "CVE-Description": "An issue was discovered in Binutils addr2line before 2.39.3, function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2022-48064",
            "CVE-Description": "GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.",
            "Severity": "LOW",
            "Mapped CWE-ID": 770,
            "CWE Description": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
            "Mapped CAPEC-ID": 130,
            "CAPEC Description": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2023-1579",
            "CVE-Description": "Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-1972",
            "CVE-Description": "A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25584",
            "CVE-Description": "An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2023-25585",
            "CVE-Description": "A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25586",
            "CVE-Description": "A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25588",
            "CVE-Description": "A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function, which may lead to an application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2017-13716",
            "CVE-Description": "The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).",
            "Severity": "LOW",
            "Mapped CWE-ID": 770,
            "CWE Description": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
            "Mapped CAPEC-ID": 130,
            "CAPEC Description": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2018-18483",
            "CVE-Description": "The get_count function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31, allows remote attackers to cause a denial of service (malloc called with the result of an integer-overflowing calculation) or possibly have unspecified other impact via a crafted string, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20673",
            "CVE-Description": "The demangle_template function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31.1, contains an integer overflow vulnerability (for \"Create an array for saving the template argument values\") that can trigger a heap-based buffer overflow, as demonstrated by nm.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20712",
            "CVE-Description": "A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty, as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults, leading to denial-of-service, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2019-1010204",
            "CVE-Description": "GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation, Signed/Unsigned Comparison, Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497, elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2020-35448",
            "CVE-Description": "An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2021-20197",
            "CVE-Description": "There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar, objcopy, strip, ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users), an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.",
            "Severity": "LOW",
            "Mapped CWE-ID": 79,
            "CWE Description": "The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.",
            "Mapped CAPEC-ID": 209,
            "CAPEC Description": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2021-32256",
            "CVE-Description": "An issue was discovered in GNU libiberty, as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-3549",
            "CVE-Description": "An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-45078",
            "CVE-Description": "stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact, as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-46174",
            "CVE-Description": "Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35205",
            "CVE-Description": "An issue was discovered in Binutils readelf 2.38.50, reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 617,
            "CWE Description": "The product contains an assert() or similar statement that can be triggered by an attacker, which leads to an application exit or other behavior that is more severe than necessary.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-617",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35206",
            "CVE-Description": "Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 129,
            "CAPEC Description": "This attack pattern involves an adversary manipulating a pointer within a target application resulting in the application accessing an unintended memory location. This can result in the crashing of the application or, for certain pointer values, access to data that would not normally be possible or the execution of arbitrary code. Since pointers are simply integer variables, Integer Attacks may often be used in Pointer Attacks.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-38533",
            "CVE-Description": "In GNU Binutils before 2.40, there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.",
            "Severity": "LOW",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 263,
            "CAPEC Description": "This describes an attack where an application is forced to use a file that an attacker has corrupted. The result is often a denial of service caused by the application being unable to process the corrupted file, but other results, including the disabling of filters or access controls (if the application fails in an unsafe way rather than failing by locking down) or buffer overflows are possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-4285",
            "CVE-Description": "An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-44840",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-45703",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-47673",
            "CVE-Description": "An issue was discovered in Binutils addr2line before 2.39.3, function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2022-48064",
            "CVE-Description": "GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.",
            "Severity": "LOW",
            "Mapped CWE-ID": 770,
            "CWE Description": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
            "Mapped CAPEC-ID": 130,
            "CAPEC Description": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2023-1579",
            "CVE-Description": "Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-1972",
            "CVE-Description": "A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25584",
            "CVE-Description": "An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2023-25585",
            "CVE-Description": "A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25586",
            "CVE-Description": "A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25588",
            "CVE-Description": "A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function, which may lead to an application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-0563",
            "CVE-Description": "A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 22,
            "CWE Description": "The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",
            "Mapped CAPEC-ID": 579,
            "CAPEC Description": "Winlogon is a part of Windows that performs logon actions. In Windows systems prior to Windows Vista, a registry key can be modified that causes Winlogon to load a DLL on startup. Adversaries may take advantage of this feature to load adversarial code at startup.",
            "Original CWE-ID": "CWE-209",
            "Original CAPEC-ID": "463, 215, 7, 54"
        },
        {
            "CVE-ID": "CVE-2022-1304",
            "CVE-Description": "An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2024-32002",
            "CVE-Description": "Git is a revision control system. Prior to versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4, repositories with submodules can be crafted in a way that exploits a bug in Git whereby it can be fooled into writing files not into the submodule's worktree but into a `.git/` directory. This allows writing a hook that will be executed while the clone operation is still running, giving the user no opportunity to inspect the code that is being executed. The problem has been patched in versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4. If symbolic link support is disabled in Git (e.g. via `git config --global core.symlinks false`), the described attack won't work. As always, it is best to avoid cloning repositories from untrusted sources.",
            "Severity": "CRITICAL",
            "Mapped CWE-ID": 59,
            "CWE Description": "The product attempts to access a file based on the filename, but it does not properly prevent that filename from identifying a link or shortcut that resolves to an unintended resource.",
            "Mapped CAPEC-ID": 209,
            "CAPEC Description": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2024-32465",
            "CVE-Description": "Git is a revision control system. The Git project recommends to avoid working in untrusted repositories, and instead to clone it first with `git clone --no-local` to obtain a clean copy. Git has specific protections to make that a safe operation even with an untrusted source repository, but vulnerabilities allow those protections to be bypassed. In the context of cloning local repositories owned by other users, this vulnerability has been covered in CVE-2024-32004. But there are circumstances where the fixes for CVE-2024-32004 are not enough: For example, when obtaining a `.zip` file containing a full copy of a Git repository, it should not be trusted by default to be safe, as e.g. hooks could be configured to run within the context of that repository. The problem has been patched in versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4. As a workaround, avoid using Git in repositories that have been obtained via archives from untrusted sources.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 459,
            "CWE Description": "The product does not properly clean up and remove temporary or supporting resources after they have been used.",
            "Mapped CAPEC-ID": 209,
            "CAPEC Description": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.",
            "Original CWE-ID": "CWE-22",
            "Original CAPEC-ID": "126, 79, 76, 78, 64"
        },
        {
            "CVE-ID": "CVE-2023-25815",
            "CVE-Description": "In Git for Windows, the Windows port of Git, no localized messages are shipped with the installer. As a consequence, Git is expected not to localize messages at all, and skips the gettext initialization. However, due to a change in MINGW-packages, the `gettext()` function's implicit initialization no longer uses the runtime prefix but uses the hard-coded path `C:\\mingw64\\share\\locale` to look for localized messages. And since any authenticated user has the permission to create folders in `C:\\` (and since `C:\\mingw64` does not typically exist), it is possible for low-privilege users to place fake messages in that location where `git.exe` will pick them up in version 2.40.1.\n\nThis vulnerability is relatively hard to exploit and requires social engineering. For example, a legitimate message at the end of a clone could be maliciously modified to ask the user to direct their web browser to a malicious website, and the user might think that the message comes from Git and is legitimate. It does require local write access by the attacker, though, which makes this attack vector less likely. Version 2.40.1 contains a patch for this issue. Some workarounds are available. Do not work on a Windows machine with shared accounts, or alternatively create a `C:\\mingw64` folder and leave it empty. Users who have administrative rights may remove the permission to create folders in `C:\\`.",
            "Severity": "LOW",
            "Mapped CWE-ID": 79,
            "CWE Description": "The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.",
            "Mapped CAPEC-ID": 487,
            "CAPEC Description": "An adversary may execute a flooding attack using the ICMP protocol with the intent to deny legitimate users access to a service by consuming the available network bandwidth. A typical attack involves a victim server receiving ICMP packets at a high rate from a wide range of source addresses. Additionally, due to the session-less nature of the ICMP protocol, the source of a packet is easily spoofed making it difficult to find the source of the attack.",
            "Original CWE-ID": "CWE-134",
            "Original CAPEC-ID": "67, 135"
        },
        {
            "CVE-ID": "CVE-2024-32020",
            "CVE-Description": "Git is a revision control system. Prior to versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4, local clones may end up hardlinking files into the target repository's object database when source and target repository reside on the same disk. If the source repository is owned by a different user, then those hardlinked files may be rewritten at any point in time by the untrusted user. Cloning local repositories will cause Git to either copy or hardlink files of the source repository into the target repository. This significantly speeds up such local clones compared to doing a \"proper\" clone and saves both disk space and compute time. When cloning a repository located on the same disk that is owned by a different user than the current user we also end up creating such hardlinks. These files will continue to be owned and controlled by the potentially-untrusted user and can be rewritten by them at will in the future. The problem has been patched in versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 79,
            "CWE Description": "The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.",
            "Mapped CAPEC-ID": 487,
            "CAPEC Description": "An adversary may execute a flooding attack using the ICMP protocol with the intent to deny legitimate users access to a service by consuming the available network bandwidth. A typical attack involves a victim server receiving ICMP packets at a high rate from a wide range of source addresses. Additionally, due to the session-less nature of the ICMP protocol, the source of a packet is easily spoofed making it difficult to find the source of the attack.",
            "Original CWE-ID": "CWE-281",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2024-32021",
            "CVE-Description": "Git is a revision control system. Prior to versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4, when cloning a local source repository that contains symlinks via the filesystem, Git may create hardlinks to arbitrary user-readable files on the same filesystem as the target repository in the `objects/` directory. Cloning a local repository over the filesystem may creating hardlinks to arbitrary user-owned files on the same filesystem in the target Git repository's `objects/` directory. When cloning a repository over the filesystem (without explicitly specifying the `file://` protocol or `--no-local`), the optimizations for local cloning\nwill be used, which include attempting to hard link the object files instead of copying them. While the code includes checks against symbolic links in the source repository, which were added during the fix for CVE-2022-39253, these checks can still be raced because the hard link operation ultimately follows symlinks. If the object on the filesystem appears as a file during the check, and then a symlink during the operation, this will allow the adversary to bypass the check and create hardlinks in the destination objects directory to arbitrary, user-readable files. The problem has been patched in versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 59,
            "CWE Description": "The product attempts to access a file based on the filename, but it does not properly prevent that filename from identifying a link or shortcut that resolves to an unintended resource.",
            "Mapped CAPEC-ID": 29,
            "CAPEC Description": "This attack targets a race condition occurring between the time of check (state) for a resource and the time of use of a resource. A typical example is file access. The adversary can leverage a file access race condition by running the race, meaning that they would modify the resource between the first time the target program accesses the file and the time the target program uses the file. During that period of time, the adversary could replace or modify the file, causing the application to behave unexpectedly.",
            "Original CWE-ID": "CWE-547",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2024-32002",
            "CVE-Description": "Git is a revision control system. Prior to versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4, repositories with submodules can be crafted in a way that exploits a bug in Git whereby it can be fooled into writing files not into the submodule's worktree but into a `.git/` directory. This allows writing a hook that will be executed while the clone operation is still running, giving the user no opportunity to inspect the code that is being executed. The problem has been patched in versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4. If symbolic link support is disabled in Git (e.g. via `git config --global core.symlinks false`), the described attack won't work. As always, it is best to avoid cloning repositories from untrusted sources.",
            "Severity": "CRITICAL",
            "Mapped CWE-ID": 59,
            "CWE Description": "The product attempts to access a file based on the filename, but it does not properly prevent that filename from identifying a link or shortcut that resolves to an unintended resource.",
            "Mapped CAPEC-ID": 209,
            "CAPEC Description": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2024-32465",
            "CVE-Description": "Git is a revision control system. The Git project recommends to avoid working in untrusted repositories, and instead to clone it first with `git clone --no-local` to obtain a clean copy. Git has specific protections to make that a safe operation even with an untrusted source repository, but vulnerabilities allow those protections to be bypassed. In the context of cloning local repositories owned by other users, this vulnerability has been covered in CVE-2024-32004. But there are circumstances where the fixes for CVE-2024-32004 are not enough: For example, when obtaining a `.zip` file containing a full copy of a Git repository, it should not be trusted by default to be safe, as e.g. hooks could be configured to run within the context of that repository. The problem has been patched in versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4. As a workaround, avoid using Git in repositories that have been obtained via archives from untrusted sources.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 459,
            "CWE Description": "The product does not properly clean up and remove temporary or supporting resources after they have been used.",
            "Mapped CAPEC-ID": 209,
            "CAPEC Description": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.",
            "Original CWE-ID": "CWE-22",
            "Original CAPEC-ID": "126, 79, 76, 78, 64"
        },
        {
            "CVE-ID": "CVE-2023-25815",
            "CVE-Description": "In Git for Windows, the Windows port of Git, no localized messages are shipped with the installer. As a consequence, Git is expected not to localize messages at all, and skips the gettext initialization. However, due to a change in MINGW-packages, the `gettext()` function's implicit initialization no longer uses the runtime prefix but uses the hard-coded path `C:\\mingw64\\share\\locale` to look for localized messages. And since any authenticated user has the permission to create folders in `C:\\` (and since `C:\\mingw64` does not typically exist), it is possible for low-privilege users to place fake messages in that location where `git.exe` will pick them up in version 2.40.1.\n\nThis vulnerability is relatively hard to exploit and requires social engineering. For example, a legitimate message at the end of a clone could be maliciously modified to ask the user to direct their web browser to a malicious website, and the user might think that the message comes from Git and is legitimate. It does require local write access by the attacker, though, which makes this attack vector less likely. Version 2.40.1 contains a patch for this issue. Some workarounds are available. Do not work on a Windows machine with shared accounts, or alternatively create a `C:\\mingw64` folder and leave it empty. Users who have administrative rights may remove the permission to create folders in `C:\\`.",
            "Severity": "LOW",
            "Mapped CWE-ID": 79,
            "CWE Description": "The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.",
            "Mapped CAPEC-ID": 487,
            "CAPEC Description": "An adversary may execute a flooding attack using the ICMP protocol with the intent to deny legitimate users access to a service by consuming the available network bandwidth. A typical attack involves a victim server receiving ICMP packets at a high rate from a wide range of source addresses. Additionally, due to the session-less nature of the ICMP protocol, the source of a packet is easily spoofed making it difficult to find the source of the attack.",
            "Original CWE-ID": "CWE-134",
            "Original CAPEC-ID": "67, 135"
        },
        {
            "CVE-ID": "CVE-2024-32020",
            "CVE-Description": "Git is a revision control system. Prior to versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4, local clones may end up hardlinking files into the target repository's object database when source and target repository reside on the same disk. If the source repository is owned by a different user, then those hardlinked files may be rewritten at any point in time by the untrusted user. Cloning local repositories will cause Git to either copy or hardlink files of the source repository into the target repository. This significantly speeds up such local clones compared to doing a \"proper\" clone and saves both disk space and compute time. When cloning a repository located on the same disk that is owned by a different user than the current user we also end up creating such hardlinks. These files will continue to be owned and controlled by the potentially-untrusted user and can be rewritten by them at will in the future. The problem has been patched in versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 79,
            "CWE Description": "The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.",
            "Mapped CAPEC-ID": 487,
            "CAPEC Description": "An adversary may execute a flooding attack using the ICMP protocol with the intent to deny legitimate users access to a service by consuming the available network bandwidth. A typical attack involves a victim server receiving ICMP packets at a high rate from a wide range of source addresses. Additionally, due to the session-less nature of the ICMP protocol, the source of a packet is easily spoofed making it difficult to find the source of the attack.",
            "Original CWE-ID": "CWE-281",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2024-32021",
            "CVE-Description": "Git is a revision control system. Prior to versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4, when cloning a local source repository that contains symlinks via the filesystem, Git may create hardlinks to arbitrary user-readable files on the same filesystem as the target repository in the `objects/` directory. Cloning a local repository over the filesystem may creating hardlinks to arbitrary user-owned files on the same filesystem in the target Git repository's `objects/` directory. When cloning a repository over the filesystem (without explicitly specifying the `file://` protocol or `--no-local`), the optimizations for local cloning\nwill be used, which include attempting to hard link the object files instead of copying them. While the code includes checks against symbolic links in the source repository, which were added during the fix for CVE-2022-39253, these checks can still be raced because the hard link operation ultimately follows symlinks. If the object on the filesystem appears as a file during the check, and then a symlink during the operation, this will allow the adversary to bypass the check and create hardlinks in the destination objects directory to arbitrary, user-readable files. The problem has been patched in versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 59,
            "CWE Description": "The product attempts to access a file based on the filename, but it does not properly prevent that filename from identifying a link or shortcut that resolves to an unintended resource.",
            "Mapped CAPEC-ID": 29,
            "CAPEC Description": "This attack targets a race condition occurring between the time of check (state) for a resource and the time of use of a resource. A typical example is file access. The adversary can leverage a file access race condition by running the race, meaning that they would modify the resource between the first time the target program accesses the file and the time the target program uses the file. During that period of time, the adversary could replace or modify the file, causing the application to behave unexpectedly.",
            "Original CWE-ID": "CWE-547",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2011-3374",
            "CVE-Description": "It was found that apt-key in apt, all versions, do not correctly validate gpg keys with the master keyring, leading to a potential man-in-the-middle attack.",
            "Severity": "LOW",
            "Mapped CWE-ID": 295,
            "CWE Description": "The product does not validate, or incorrectly validates, a certificate.",
            "Mapped CAPEC-ID": 209,
            "CAPEC Description": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.",
            "Original CWE-ID": "CWE-347",
            "Original CAPEC-ID": "475, 463"
        },
        {
            "CVE-ID": "CVE-2017-13716",
            "CVE-Description": "The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).",
            "Severity": "LOW",
            "Mapped CWE-ID": 770,
            "CWE Description": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
            "Mapped CAPEC-ID": 130,
            "CAPEC Description": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2018-18483",
            "CVE-Description": "The get_count function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31, allows remote attackers to cause a denial of service (malloc called with the result of an integer-overflowing calculation) or possibly have unspecified other impact via a crafted string, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20673",
            "CVE-Description": "The demangle_template function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31.1, contains an integer overflow vulnerability (for \"Create an array for saving the template argument values\") that can trigger a heap-based buffer overflow, as demonstrated by nm.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20712",
            "CVE-Description": "A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty, as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults, leading to denial-of-service, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2019-1010204",
            "CVE-Description": "GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation, Signed/Unsigned Comparison, Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497, elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2020-35448",
            "CVE-Description": "An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2021-20197",
            "CVE-Description": "There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar, objcopy, strip, ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users), an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.",
            "Severity": "LOW",
            "Mapped CWE-ID": 79,
            "CWE Description": "The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.",
            "Mapped CAPEC-ID": 209,
            "CAPEC Description": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2021-32256",
            "CVE-Description": "An issue was discovered in GNU libiberty, as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-3549",
            "CVE-Description": "An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-45078",
            "CVE-Description": "stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact, as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-46174",
            "CVE-Description": "Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35205",
            "CVE-Description": "An issue was discovered in Binutils readelf 2.38.50, reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 617,
            "CWE Description": "The product contains an assert() or similar statement that can be triggered by an attacker, which leads to an application exit or other behavior that is more severe than necessary.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-617",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35206",
            "CVE-Description": "Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 129,
            "CAPEC Description": "This attack pattern involves an adversary manipulating a pointer within a target application resulting in the application accessing an unintended memory location. This can result in the crashing of the application or, for certain pointer values, access to data that would not normally be possible or the execution of arbitrary code. Since pointers are simply integer variables, Integer Attacks may often be used in Pointer Attacks.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-38533",
            "CVE-Description": "In GNU Binutils before 2.40, there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.",
            "Severity": "LOW",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 263,
            "CAPEC Description": "This describes an attack where an application is forced to use a file that an attacker has corrupted. The result is often a denial of service caused by the application being unable to process the corrupted file, but other results, including the disabling of filters or access controls (if the application fails in an unsafe way rather than failing by locking down) or buffer overflows are possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-4285",
            "CVE-Description": "An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-44840",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-45703",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-47673",
            "CVE-Description": "An issue was discovered in Binutils addr2line before 2.39.3, function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2022-48064",
            "CVE-Description": "GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.",
            "Severity": "LOW",
            "Mapped CWE-ID": 770,
            "CWE Description": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
            "Mapped CAPEC-ID": 130,
            "CAPEC Description": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2023-1579",
            "CVE-Description": "Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-1972",
            "CVE-Description": "A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25584",
            "CVE-Description": "An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2023-25585",
            "CVE-Description": "A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25586",
            "CVE-Description": "A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25588",
            "CVE-Description": "A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function, which may lead to an application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-0563",
            "CVE-Description": "A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 22,
            "CWE Description": "The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",
            "Mapped CAPEC-ID": 579,
            "CAPEC Description": "Winlogon is a part of Windows that performs logon actions. In Windows systems prior to Windows Vista, a registry key can be modified that causes Winlogon to load a DLL on startup. Adversaries may take advantage of this feature to load adversarial code at startup.",
            "Original CWE-ID": "CWE-209",
            "Original CAPEC-ID": "463, 215, 7, 54"
        },
        {
            "CVE-ID": "CVE-2024-33600",
            "CVE-Description": "nscd: Null pointer crashes after notfound response\n\nIf the Name Service Cache Daemon's (nscd) cache fails to add a not-found\nnetgroup response to the cache, the client request can result in a null\npointer dereference.  This flaw was introduced in glibc 2.15 when the\ncache was added to nscd.\n\nThis vulnerability is only present in the nscd binary.\n\n",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 209,
            "CAPEC Description": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2024-33601",
            "CVE-Description": "nscd: netgroup cache may terminate daemon on memory allocation failure\n\nThe Name Service Cache Daemon's (nscd) netgroup cache uses xmalloc or\nxrealloc and these functions may terminate the process due to a memory\nallocation failure resulting in a denial of service to the clients.  The\nflaw was introduced in glibc 2.15 when the cache was added to nscd.\n\nThis vulnerability is only present in the nscd binary.\n\n",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 770,
            "CWE Description": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
            "Mapped CAPEC-ID": 130,
            "CAPEC Description": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.",
            "Original CWE-ID": "CWE-617",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2024-33602",
            "CVE-Description": "nscd: netgroup cache assumes NSS callback uses in-buffer strings\n\nThe Name Service Cache Daemon's (nscd) netgroup cache can corrupt memory\nwhen the NSS callback does not store all strings in the provided buffer.\nThe flaw was introduced in glibc 2.15 when the cache was added to nscd.\n\nThis vulnerability is only present in the nscd binary.\n\n",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 487,
            "CAPEC Description": "An adversary may execute a flooding attack using the ICMP protocol with the intent to deny legitimate users access to a service by consuming the available network bandwidth. A typical attack involves a victim server receiving ICMP packets at a high rate from a wide range of source addresses. Additionally, due to the session-less nature of the ICMP protocol, the source of a packet is easily spoofed making it difficult to find the source of the attack.",
            "Original CWE-ID": "CWE-466",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-1304",
            "CVE-Description": "An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2017-13716",
            "CVE-Description": "The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).",
            "Severity": "LOW",
            "Mapped CWE-ID": 770,
            "CWE Description": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
            "Mapped CAPEC-ID": 130,
            "CAPEC Description": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2018-18483",
            "CVE-Description": "The get_count function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31, allows remote attackers to cause a denial of service (malloc called with the result of an integer-overflowing calculation) or possibly have unspecified other impact via a crafted string, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20673",
            "CVE-Description": "The demangle_template function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31.1, contains an integer overflow vulnerability (for \"Create an array for saving the template argument values\") that can trigger a heap-based buffer overflow, as demonstrated by nm.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20712",
            "CVE-Description": "A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty, as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults, leading to denial-of-service, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2019-1010204",
            "CVE-Description": "GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation, Signed/Unsigned Comparison, Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497, elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2020-35448",
            "CVE-Description": "An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2021-20197",
            "CVE-Description": "There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar, objcopy, strip, ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users), an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.",
            "Severity": "LOW",
            "Mapped CWE-ID": 79,
            "CWE Description": "The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.",
            "Mapped CAPEC-ID": 209,
            "CAPEC Description": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2021-32256",
            "CVE-Description": "An issue was discovered in GNU libiberty, as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-3549",
            "CVE-Description": "An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-45078",
            "CVE-Description": "stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact, as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-46174",
            "CVE-Description": "Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35205",
            "CVE-Description": "An issue was discovered in Binutils readelf 2.38.50, reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 617,
            "CWE Description": "The product contains an assert() or similar statement that can be triggered by an attacker, which leads to an application exit or other behavior that is more severe than necessary.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-617",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35206",
            "CVE-Description": "Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 129,
            "CAPEC Description": "This attack pattern involves an adversary manipulating a pointer within a target application resulting in the application accessing an unintended memory location. This can result in the crashing of the application or, for certain pointer values, access to data that would not normally be possible or the execution of arbitrary code. Since pointers are simply integer variables, Integer Attacks may often be used in Pointer Attacks.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-38533",
            "CVE-Description": "In GNU Binutils before 2.40, there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.",
            "Severity": "LOW",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 263,
            "CAPEC Description": "This describes an attack where an application is forced to use a file that an attacker has corrupted. The result is often a denial of service caused by the application being unable to process the corrupted file, but other results, including the disabling of filters or access controls (if the application fails in an unsafe way rather than failing by locking down) or buffer overflows are possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-4285",
            "CVE-Description": "An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-44840",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-45703",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-47673",
            "CVE-Description": "An issue was discovered in Binutils addr2line before 2.39.3, function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2022-48064",
            "CVE-Description": "GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.",
            "Severity": "LOW",
            "Mapped CWE-ID": 770,
            "CWE Description": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
            "Mapped CAPEC-ID": 130,
            "CAPEC Description": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2023-1579",
            "CVE-Description": "Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-1972",
            "CVE-Description": "A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25584",
            "CVE-Description": "An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2023-25585",
            "CVE-Description": "A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25586",
            "CVE-Description": "A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25588",
            "CVE-Description": "A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function, which may lead to an application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2017-13716",
            "CVE-Description": "The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).",
            "Severity": "LOW",
            "Mapped CWE-ID": 770,
            "CWE Description": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
            "Mapped CAPEC-ID": 130,
            "CAPEC Description": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2018-18483",
            "CVE-Description": "The get_count function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31, allows remote attackers to cause a denial of service (malloc called with the result of an integer-overflowing calculation) or possibly have unspecified other impact via a crafted string, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20673",
            "CVE-Description": "The demangle_template function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31.1, contains an integer overflow vulnerability (for \"Create an array for saving the template argument values\") that can trigger a heap-based buffer overflow, as demonstrated by nm.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20712",
            "CVE-Description": "A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty, as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults, leading to denial-of-service, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2019-1010204",
            "CVE-Description": "GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation, Signed/Unsigned Comparison, Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497, elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2020-35448",
            "CVE-Description": "An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2021-20197",
            "CVE-Description": "There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar, objcopy, strip, ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users), an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.",
            "Severity": "LOW",
            "Mapped CWE-ID": 79,
            "CWE Description": "The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.",
            "Mapped CAPEC-ID": 209,
            "CAPEC Description": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2021-32256",
            "CVE-Description": "An issue was discovered in GNU libiberty, as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-3549",
            "CVE-Description": "An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-45078",
            "CVE-Description": "stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact, as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-46174",
            "CVE-Description": "Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35205",
            "CVE-Description": "An issue was discovered in Binutils readelf 2.38.50, reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 617,
            "CWE Description": "The product contains an assert() or similar statement that can be triggered by an attacker, which leads to an application exit or other behavior that is more severe than necessary.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-617",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35206",
            "CVE-Description": "Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 129,
            "CAPEC Description": "This attack pattern involves an adversary manipulating a pointer within a target application resulting in the application accessing an unintended memory location. This can result in the crashing of the application or, for certain pointer values, access to data that would not normally be possible or the execution of arbitrary code. Since pointers are simply integer variables, Integer Attacks may often be used in Pointer Attacks.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-38533",
            "CVE-Description": "In GNU Binutils before 2.40, there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.",
            "Severity": "LOW",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 263,
            "CAPEC Description": "This describes an attack where an application is forced to use a file that an attacker has corrupted. The result is often a denial of service caused by the application being unable to process the corrupted file, but other results, including the disabling of filters or access controls (if the application fails in an unsafe way rather than failing by locking down) or buffer overflows are possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-4285",
            "CVE-Description": "An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-44840",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-45703",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-47673",
            "CVE-Description": "An issue was discovered in Binutils addr2line before 2.39.3, function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2022-48064",
            "CVE-Description": "GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.",
            "Severity": "LOW",
            "Mapped CWE-ID": 770,
            "CWE Description": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
            "Mapped CAPEC-ID": 130,
            "CAPEC Description": "An adversary causes the target to allocate excessive resources to servicing the attackers' request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2023-1579",
            "CVE-Description": "Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-1972",
            "CVE-Description": "A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25584",
            "CVE-Description": "An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2023-25585",
            "CVE-Description": "A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25586",
            "CVE-Description": "A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25588",
            "CVE-Description": "A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function, which may lead to an application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-23914",
            "CVE-Description": "A cleartext transmission of sensitive information vulnerability exists in curl <v7.88.0 that could cause HSTS functionality fail when multiple URLs are requested serially. Using its HSTS support, curl can be instructed to use HTTPS instead of usingan insecure clear-text HTTP step even when HTTP is provided in the URL. ThisHSTS mechanism would however surprisingly be ignored by subsequent transferswhen done on the same command line because the state would not be properlycarried on.",
            "Severity": "CRITICAL",
            "Mapped CWE-ID": 319,
            "CWE Description": "The product transmits sensitive or security-critical data in cleartext in a communication channel that can be sniffed by unauthorized actors.",
            "Mapped CAPEC-ID": 209,
            "CAPEC Description": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.",
            "Original CWE-ID": "CWE-319",
            "Original CAPEC-ID": "102, 117, 383, 477, 65"
        },
        {
            "CVE-ID": "CVE-2022-42916",
            "CVE-Description": "In curl before 7.86.0, the HSTS check could be bypassed to trick it into staying with HTTP. Using its HSTS support, curl can be instructed to use HTTPS directly (instead of using an insecure cleartext HTTP step) even when HTTP is provided in the URL. This mechanism could be bypassed if the host name in the given URL uses IDN characters that get replaced with ASCII counterparts as part of the IDN conversion, e.g., using the character UTF-8 U+3002 (IDEOGRAPHIC FULL STOP) instead of the common ASCII full stop of U+002E (.). The earliest affected version is 7.77.0 2021-05-26.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 312,
            "CWE Description": "The product stores sensitive information in cleartext within a resource that might be accessible to another control sphere.",
            "Mapped CAPEC-ID": 209,
            "CAPEC Description": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.",
            "Original CWE-ID": "CWE-319",
            "Original CAPEC-ID": "102, 117, 383, 477, 65"
        },
        {
            "CVE-ID": "CVE-2022-43551",
            "CVE-Description": "A vulnerability exists in curl <7.87.0 HSTS check that could be bypassed to trick it to keep using HTTP. Using its HSTS support, curl can be instructed to use HTTPS instead of using an insecure clear-text HTTP step even when HTTP is provided in the URL. However, the HSTS mechanism could be bypassed if the host name in the given URL first uses IDN characters that get replaced to ASCII counterparts as part of the IDN conversion. Like using the character UTF-8 U+3002 (IDEOGRAPHIC FULL STOP) instead of the common ASCII full stop (U+002E) `.`. Then in a subsequent request, it does not detect the HSTS state and makes a clear text transfer. Because it would store the info IDN encoded but look for it IDN decoded.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 444,
            "CWE Description": "The product acts as an intermediary HTTP agent (such as a proxy or firewall) in the data flow between two entities such as a client and server, but it does not interpret malformed HTTP requests or responses in ways that are consistent with how the messages will be processed by those entities that are at the ultimate destination.",
            "Mapped CAPEC-ID": 209,
            "CAPEC Description": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.",
            "Original CWE-ID": "CWE-319",
            "Original CAPEC-ID": "102, 117, 383, 477, 65"
        },
        {
            "CVE-ID": "CVE-2013-0340",
            "CVE-Description": "expat 2.1.0 and earlier does not properly handle entities expansion unless an application developer uses the XML_SetEntityDeclHandler function, which allows remote attackers to cause a denial of service (resource consumption), send HTTP requests to intranet servers, or read arbitrary files via a crafted XML document, aka an XML External Entity (XXE) issue.  NOTE: it could be argued that because expat already provides the ability to disable external entity expansion, the responsibility for resolving this issue lies with application developers; according to this argument, this entry should be REJECTed, and each affected application would need its own CVE.",
            "Severity": "LOW",
            "Mapped CWE-ID": 611,
            "CWE Description": "The product processes an XML document that can contain XML entities with URIs that resolve to documents outside of the intended sphere of control, causing the product to embed incorrect documents into its output.",
            "Mapped CAPEC-ID": 228,
            "CAPEC Description": "An attacker injects malicious content into an application's DTD in an attempt to produce a negative technical impact. DTDs are used to describe how XML documents are processed. Certain malformed DTDs (for example, those with excessive entity expansion as described in CAPEC 197) can cause the XML parsers that process the DTDs to consume excessive resources resulting in resource depletion.",
            "Original CWE-ID": "CWE-611",
            "Original CAPEC-ID": "221"
        },
        {
            "CVE-ID": "CVE-2023-52426",
            "CVE-Description": "libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.",
            "Severity": "LOW",
            "Mapped CWE-ID": 611,
            "CWE Description": "The product processes an XML document that can contain XML entities with URIs that resolve to documents outside of the intended sphere of control, causing the product to embed incorrect documents into its output.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-776",
            "Original CAPEC-ID": "197"
        },
        {
            "CVE-ID": "CVE-2022-1304",
            "CVE-Description": "An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2022-31782",
            "CVE-Description": "ftbench.c in FreeType Demo Programs through 2.12.1 has a heap-based buffer overflow.",
            "Severity": "LOW",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-38115",
            "CVE-Description": "read_header_tga in gd_tga.c in the GD Graphics Library (aka LibGD) through 2.3.2 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted TGA file.",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2021-40812",
            "CVE-Description": "The GD Graphics Library (aka LibGD) through 2.3.2 has an out-of-bounds read because of the lack of certain gdGetBuf and gdPutBuf return value checks.",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2024-28835",
            "CVE-Description": "A flaw has been discovered in GnuTLS where an application crash can be induced when attempting to verify a specially crafted .pem bundle using the \"certtool --verify-chain\" command.",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 306,
            "CWE Description": "The product does not perform any authentication for functionality that requires a provable user identity or consumes a significant amount of resources.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-248",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2018-5709",
            "CVE-Description": "An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable \"dbentry->n_key_data\" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a \"u4\" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.",
            "Severity": "LOW",
            "Mapped CWE-ID": 281,
            "CWE Description": "The product does not preserve permissions or incorrectly preserves permissions when copying, restoring, or sharing objects, which can cause them to have less restrictive permissions than intended.",
            "Mapped CAPEC-ID": 37,
            "CAPEC Description": "An attacker examines a target system to find sensitive data that has been embedded within it. This information can reveal confidential contents, such as account numbers or individual keys/credentials that can be used as an intermediate step in a larger attack.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-5709",
            "CVE-Description": "An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable \"dbentry->n_key_data\" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a \"u4\" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.",
            "Severity": "LOW",
            "Mapped CWE-ID": 281,
            "CWE Description": "The product does not preserve permissions or incorrectly preserves permissions when copying, restoring, or sharing objects, which can cause them to have less restrictive permissions than intended.",
            "Mapped CAPEC-ID": 37,
            "CAPEC Description": "An attacker examines a target system to find sensitive data that has been embedded within it. This information can reveal confidential contents, such as account numbers or individual keys/credentials that can be used as an intermediate step in a larger attack.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-5709",
            "CVE-Description": "An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable \"dbentry->n_key_data\" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a \"u4\" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.",
            "Severity": "LOW",
            "Mapped CWE-ID": 281,
            "CWE Description": "The product does not preserve permissions or incorrectly preserves permissions when copying, restoring, or sharing objects, which can cause them to have less restrictive permissions than intended.",
            "Mapped CAPEC-ID": 37,
            "CAPEC Description": "An attacker examines a target system to find sensitive data that has been embedded within it. This information can reveal confidential contents, such as account numbers or individual keys/credentials that can be used as an intermediate step in a larger attack.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-5709",
            "CVE-Description": "An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable \"dbentry->n_key_data\" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a \"u4\" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.",
            "Severity": "LOW",
            "Mapped CWE-ID": 281,
            "CWE Description": "The product does not preserve permissions or incorrectly preserves permissions when copying, restoring, or sharing objects, which can cause them to have less restrictive permissions than intended.",
            "Mapped CAPEC-ID": 37,
            "CAPEC Description": "An attacker examines a target system to find sensitive data that has been embedded within it. This information can reveal confidential contents, such as account numbers or individual keys/credentials that can be used as an intermediate step in a larger attack.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2023-2953",
            "CVE-Description": "A vulnerability was found in openldap. This security flaw causes a null pointer dereference in ber_memalloc_x() function.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2020-15719",
            "CVE-Description": "libldap in certain third-party OpenLDAP packages has a certificate-validation flaw when the third-party package is asserting RFC6125 support. It considers CN even when there is a non-matching subjectAltName (SAN). This is fixed in, for example, openldap-2.4.46-10.el8 in Red Hat Enterprise Linux.",
            "Severity": "LOW",
            "Mapped CWE-ID": 295,
            "CWE Description": "The product does not validate, or incorrectly validates, a certificate.",
            "Mapped CAPEC-ID": 209,
            "CAPEC Description": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.",
            "Original CWE-ID": "CWE-295",
            "Original CAPEC-ID": "475, 459"
        },
        {
            "CVE-ID": "CVE-2022-0563",
            "CVE-Description": "A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 22,
            "CWE Description": "The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",
            "Mapped CAPEC-ID": 579,
            "CAPEC Description": "Winlogon is a part of Windows that performs logon actions. In Windows systems prior to Windows Vista, a registry key can be modified that causes Winlogon to load a DLL on startup. Adversaries may take advantage of this feature to load adversarial code at startup.",
            "Original CWE-ID": "CWE-209",
            "Original CAPEC-ID": "463, 215, 7, 54"
        },
        {
            "CVE-ID": "CVE-2019-20838",
            "CVE-Description": "libpcre in PCRE before 8.43 allows a subject buffer over-read in JIT when UTF is disabled, and \\X or \\R has more than one fixed quantifier, a related issue to CVE-2019-20454.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2020-16156",
            "CVE-Description": "CPAN 2.28 allows Signature Verification Bypass.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 347,
            "CWE Description": "The product does not verify, or incorrectly verifies, the cryptographic signature for data.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-347",
            "Original CAPEC-ID": "475, 463"
        },
        {
            "CVE-ID": "CVE-2023-31484",
            "CVE-Description": "CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 295,
            "CWE Description": "The product does not validate, or incorrectly validates, a certificate.",
            "Mapped CAPEC-ID": 661,
            "CAPEC Description": "An adversary inserts a debugger into the program entry point of a mobile application to modify the application binary, with the goal of evading Root/Jailbreak detection. Mobile device users often Root/Jailbreak their devices in order to gain administrative control over the mobile operating system and/or to install third-party mobile applications that are not provided by authorized application stores (e.g. Google Play Store and Apple App Store). Rooting/Jailbreaking a mobile device also provides users with access to system debuggers and disassemblers, which can be leveraged to exploit applications by dumping the application's memory at runtime in order to remove or bypass signature verification methods. This further allows the adversary to evade Root/Jailbreak detection mechanisms, which can result in execution of administrative commands, obtaining confidential data, impersonating legitimate users of the application, and more.",
            "Original CWE-ID": "CWE-295",
            "Original CAPEC-ID": "475, 459"
        },
        {
            "CVE-ID": "CVE-2023-47038",
            "CVE-Description": "A vulnerability was found in perl 5.30.0 through 5.38.0. This issue occurs when a crafted regular expression is compiled by perl, which can allow an attacker controlled byte buffer overflow in a heap allocated buffer.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2011-4116",
            "CVE-Description": "_is_safe in the File::Temp module for Perl does not properly handle symlinks.",
            "Severity": "LOW",
            "Mapped CWE-ID": 79,
            "CWE Description": "The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2023-31486",
            "CVE-Description": "HTTP::Tiny before 0.083, a Perl core module since 5.13.9 and available standalone on CPAN, has an insecure default TLS configuration where users must opt in to verify certificates.",
            "Severity": "LOW",
            "Mapped CWE-ID": 306,
            "CWE Description": "The product does not perform any authentication for functionality that requires a provable user identity or consumes a significant amount of resources.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-295",
            "Original CAPEC-ID": "475, 459"
        },
        {
            "CVE-ID": "CVE-2023-4016",
            "CVE-Description": "Under some circumstances, this weakness allows a user who has access to run the \u201cps\u201d utility on a machine, the ability to write almost unlimited amounts of unfiltered data into the process heap.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-28861",
            "CVE-Description": "Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states \"Warning: http.server is not recommended for production. It only implements basic security checks.\"",
            "Severity": "LOW",
            "Mapped CWE-ID": 601,
            "CWE Description": "A web application accepts a user-controlled input that specifies a link to an external site, and uses that link in a Redirect. This simplifies phishing attacks.",
            "Mapped CAPEC-ID": 178,
            "CAPEC Description": "An attacker is able to trick the victim into executing a Flash document that passes commands or calls to a Flash player browser plugin, allowing the attacker to exploit native Flash functionality in the client browser. This attack pattern occurs where an attacker can provide a crafted link to a Flash document (SWF file) which, when followed, will cause additional malicious instructions to be executed. The attacker does not need to serve or control the Flash document. The attack takes advantage of the fact that Flash files can reference external URLs. If variables that serve as URLs that the Flash application references can be controlled through parameters, then by creating a link that includes values for those parameters, an attacker can cause arbitrary content to be referenced and possibly executed by the targeted Flash application.",
            "Original CWE-ID": "CWE-601",
            "Original CAPEC-ID": "178"
        },
        {
            "CVE-ID": "CVE-2022-37454",
            "CVE-Description": "The Keccak XKCP SHA-3 reference implementation before fdc6fef has an integer overflow and resultant buffer overflow that allows attackers to execute arbitrary code or eliminate expected cryptographic properties. This occurs in the sponge function interface.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2021-28861",
            "CVE-Description": "Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states \"Warning: http.server is not recommended for production. It only implements basic security checks.\"",
            "Severity": "LOW",
            "Mapped CWE-ID": 601,
            "CWE Description": "A web application accepts a user-controlled input that specifies a link to an external site, and uses that link in a Redirect. This simplifies phishing attacks.",
            "Mapped CAPEC-ID": 178,
            "CAPEC Description": "An attacker is able to trick the victim into executing a Flash document that passes commands or calls to a Flash player browser plugin, allowing the attacker to exploit native Flash functionality in the client browser. This attack pattern occurs where an attacker can provide a crafted link to a Flash document (SWF file) which, when followed, will cause additional malicious instructions to be executed. The attacker does not need to serve or control the Flash document. The attack takes advantage of the fact that Flash files can reference external URLs. If variables that serve as URLs that the Flash application references can be controlled through parameters, then by creating a link that includes values for those parameters, an attacker can cause arbitrary content to be referenced and possibly executed by the targeted Flash application.",
            "Original CWE-ID": "CWE-601",
            "Original CAPEC-ID": "178"
        },
        {
            "CVE-ID": "CVE-2022-37454",
            "CVE-Description": "The Keccak XKCP SHA-3 reference implementation before fdc6fef has an integer overflow and resultant buffer overflow that allows attackers to execute arbitrary code or eliminate expected cryptographic properties. This occurs in the sponge function interface.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2021-36087",
            "CVE-Description": "The CIL compiler in SELinux 3.2 has a heap-based buffer over-read in ebitmap_match_any (called indirectly from cil_check_neverallow). This occurs because there is sometimes a lack of checks for invalid statements in an optional block.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2022-0563",
            "CVE-Description": "A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 22,
            "CWE Description": "The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",
            "Mapped CAPEC-ID": 579,
            "CAPEC Description": "Winlogon is a part of Windows that performs logon actions. In Windows systems prior to Windows Vista, a registry key can be modified that causes Winlogon to load a DLL on startup. Adversaries may take advantage of this feature to load adversarial code at startup.",
            "Original CWE-ID": "CWE-209",
            "Original CAPEC-ID": "463, 215, 7, 54"
        },
        {
            "CVE-ID": "CVE-2022-1304",
            "CVE-Description": "An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2020-22218",
            "CVE-Description": "An issue was discovered in function _libssh2_packet_add in libssh2 1.10.0 allows attackers to access out of bounds memory.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2013-4392",
            "CVE-Description": "systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.",
            "Severity": "LOW",
            "Mapped CWE-ID": 276,
            "CWE Description": "During installation, installed file permissions are set to allow anyone to modify those files.",
            "Mapped CAPEC-ID": 81,
            "CAPEC Description": "Web Logs Tampering attacks involve an attacker injecting, deleting or otherwise tampering with the contents of web logs typically for the purposes of masking other malicious behavior. Additionally, writing malicious data to log files may target jobs, filters, reports, and other agents that process the logs in an asynchronous attack pattern. This pattern of attack is similar to Log Injection-Tampering-Forging except that in this case, the attack is targeting the logs of the web server and not the application.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2020-13529",
            "CVE-Description": "An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.",
            "Severity": "LOW",
            "Mapped CWE-ID": 306,
            "CWE Description": "The product does not perform any authentication for functionality that requires a provable user identity or consumes a significant amount of resources.",
            "Mapped CAPEC-ID": 389,
            "CAPEC Description": "An attacker manipulates either egress or ingress data from a client within an application framework in order to change the content of messages. Performing this attack allows the attacker to manipulate content in such a way as to produce messages or content that look authentic but may contain deceptive links, spam-like content, or links to the attackers' code. In general, content-spoofing within an application API can be employed to stage many different types of attacks varied based on the attackers' intent. The techniques require use of specialized software that allow the attacker to use adversary-in-the-middle (CAPEC-94) communications between the web browser and the remote system.",
            "Original CWE-ID": "CWE-290",
            "Original CAPEC-ID": "459, 667, 60, 59, 476, 473, 94, 21, 22, 461"
        },
        {
            "CVE-ID": "CVE-2023-31437",
            "CVE-Description": "An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
            "Severity": "LOW",
            "Mapped CWE-ID": 306,
            "CWE Description": "The product does not perform any authentication for functionality that requires a provable user identity or consumes a significant amount of resources.",
            "Mapped CAPEC-ID": 33,
            "CAPEC Description": "An adversary abuses the flexibility and discrepancies in the parsing and interpretation of HTTP Request messages using various HTTP headers, request-line and body parameters as well as message sizes (denoted by the end of message signaled by a given HTTP header) by different intermediary HTTP agents (e.g., load balancer, reverse proxy, web caching proxies, application firewalls, etc.) to secretly send unauthorized and malicious HTTP requests to a back-end HTTP agent (e.g., web server). See CanPrecede relationships for possible consequences.",
            "Original CWE-ID": "CWE-354",
            "Original CAPEC-ID": "145, 463, 75"
        },
        {
            "CVE-ID": "CVE-2023-31438",
            "CVE-Description": "An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
            "Severity": "LOW",
            "Mapped CWE-ID": 354,
            "CWE Description": "The product does not validate or incorrectly validates the integrity check values or checksums of a message. This may prevent it from detecting if the data has been modified or corrupted in transmission.",
            "Mapped CAPEC-ID": 33,
            "CAPEC Description": "An adversary abuses the flexibility and discrepancies in the parsing and interpretation of HTTP Request messages using various HTTP headers, request-line and body parameters as well as message sizes (denoted by the end of message signaled by a given HTTP header) by different intermediary HTTP agents (e.g., load balancer, reverse proxy, web caching proxies, application firewalls, etc.) to secretly send unauthorized and malicious HTTP requests to a back-end HTTP agent (e.g., web server). See CanPrecede relationships for possible consequences.",
            "Original CWE-ID": "CWE-354",
            "Original CAPEC-ID": "145, 463, 75"
        },
        {
            "CVE-ID": "CVE-2023-31439",
            "CVE-Description": "An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
            "Severity": "LOW",
            "Mapped CWE-ID": 354,
            "CWE Description": "The product does not validate or incorrectly validates the integrity check values or checksums of a message. This may prevent it from detecting if the data has been modified or corrupted in transmission.",
            "Mapped CAPEC-ID": 209,
            "CAPEC Description": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.",
            "Original CWE-ID": "CWE-354",
            "Original CAPEC-ID": "145, 463, 75"
        },
        {
            "CVE-ID": "CVE-2023-52355",
            "CVE-Description": "An out-of-memory flaw was found in libtiff that could be triggered by passing a crafted tiff file to the TIFFRasterScanlineSize64() API. This flaw allows a remote attacker to cause a denial of service via a crafted input with a size smaller than 379 KB.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 770,
            "CWE Description": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-52356",
            "CVE-Description": "A segment fault (SEGV) flaw was found in libtiff that could be triggered by passing a crafted tiff file to the TIFFReadRGBATileExt() API. This flaw allows a remote attacker to cause a heap-buffer overflow, leading to a denial of service.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-40090",
            "CVE-Description": "An issue was discovered in function TIFFReadDirectory libtiff before 4.4.0 allows attackers to cause a denial of service via crafted TIFF file.",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 835,
            "CWE Description": "The product contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-835",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25433",
            "CVE-Description": "libtiff 4.5.0 is vulnerable to Buffer Overflow via /libtiff/tools/tiffcrop.c:8499. Incorrect updating of buffer size after rotateImage() in tiffcrop cause heap-buffer-overflow and SEGV.",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-120",
            "Original CAPEC-ID": "100, 92, 9, 14, 47, 24, 10, 44, 8, 67, 42, 45, 46"
        },
        {
            "CVE-ID": "CVE-2017-16232",
            "CVE-Description": "LibTIFF 4.0.8 has multiple memory leak vulnerabilities, which allow attackers to cause a denial of service (memory consumption), as demonstrated by tif_open.c, tif_lzw.c, and tif_aux.c. NOTE: Third parties were unable to reproduce the issue",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-772",
            "Original CAPEC-ID": "469"
        },
        {
            "CVE-ID": "CVE-2013-4392",
            "CVE-Description": "systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.",
            "Severity": "LOW",
            "Mapped CWE-ID": 276,
            "CWE Description": "During installation, installed file permissions are set to allow anyone to modify those files.",
            "Mapped CAPEC-ID": 81,
            "CAPEC Description": "Web Logs Tampering attacks involve an attacker injecting, deleting or otherwise tampering with the contents of web logs typically for the purposes of masking other malicious behavior. Additionally, writing malicious data to log files may target jobs, filters, reports, and other agents that process the logs in an asynchronous attack pattern. This pattern of attack is similar to Log Injection-Tampering-Forging except that in this case, the attack is targeting the logs of the web server and not the application.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2020-13529",
            "CVE-Description": "An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.",
            "Severity": "LOW",
            "Mapped CWE-ID": 306,
            "CWE Description": "The product does not perform any authentication for functionality that requires a provable user identity or consumes a significant amount of resources.",
            "Mapped CAPEC-ID": 389,
            "CAPEC Description": "An attacker manipulates either egress or ingress data from a client within an application framework in order to change the content of messages. Performing this attack allows the attacker to manipulate content in such a way as to produce messages or content that look authentic but may contain deceptive links, spam-like content, or links to the attackers' code. In general, content-spoofing within an application API can be employed to stage many different types of attacks varied based on the attackers' intent. The techniques require use of specialized software that allow the attacker to use adversary-in-the-middle (CAPEC-94) communications between the web browser and the remote system.",
            "Original CWE-ID": "CWE-290",
            "Original CAPEC-ID": "459, 667, 60, 59, 476, 473, 94, 21, 22, 461"
        },
        {
            "CVE-ID": "CVE-2023-31437",
            "CVE-Description": "An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
            "Severity": "LOW",
            "Mapped CWE-ID": 306,
            "CWE Description": "The product does not perform any authentication for functionality that requires a provable user identity or consumes a significant amount of resources.",
            "Mapped CAPEC-ID": 33,
            "CAPEC Description": "An adversary abuses the flexibility and discrepancies in the parsing and interpretation of HTTP Request messages using various HTTP headers, request-line and body parameters as well as message sizes (denoted by the end of message signaled by a given HTTP header) by different intermediary HTTP agents (e.g., load balancer, reverse proxy, web caching proxies, application firewalls, etc.) to secretly send unauthorized and malicious HTTP requests to a back-end HTTP agent (e.g., web server). See CanPrecede relationships for possible consequences.",
            "Original CWE-ID": "CWE-354",
            "Original CAPEC-ID": "145, 463, 75"
        },
        {
            "CVE-ID": "CVE-2023-31438",
            "CVE-Description": "An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
            "Severity": "LOW",
            "Mapped CWE-ID": 354,
            "CWE Description": "The product does not validate or incorrectly validates the integrity check values or checksums of a message. This may prevent it from detecting if the data has been modified or corrupted in transmission.",
            "Mapped CAPEC-ID": 33,
            "CAPEC Description": "An adversary abuses the flexibility and discrepancies in the parsing and interpretation of HTTP Request messages using various HTTP headers, request-line and body parameters as well as message sizes (denoted by the end of message signaled by a given HTTP header) by different intermediary HTTP agents (e.g., load balancer, reverse proxy, web caching proxies, application firewalls, etc.) to secretly send unauthorized and malicious HTTP requests to a back-end HTTP agent (e.g., web server). See CanPrecede relationships for possible consequences.",
            "Original CWE-ID": "CWE-354",
            "Original CAPEC-ID": "145, 463, 75"
        },
        {
            "CVE-ID": "CVE-2023-31439",
            "CVE-Description": "An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
            "Severity": "LOW",
            "Mapped CWE-ID": 354,
            "CWE Description": "The product does not validate or incorrectly validates the integrity check values or checksums of a message. This may prevent it from detecting if the data has been modified or corrupted in transmission.",
            "Mapped CAPEC-ID": 209,
            "CAPEC Description": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.",
            "Original CWE-ID": "CWE-354",
            "Original CAPEC-ID": "145, 463, 75"
        },
        {
            "CVE-ID": "CVE-2022-0563",
            "CVE-Description": "A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 22,
            "CWE Description": "The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",
            "Mapped CAPEC-ID": 579,
            "CAPEC Description": "Winlogon is a part of Windows that performs logon actions. In Windows systems prior to Windows Vista, a registry key can be modified that causes Winlogon to load a DLL on startup. Adversaries may take advantage of this feature to load adversarial code at startup.",
            "Original CWE-ID": "CWE-209",
            "Original CAPEC-ID": "463, 215, 7, 54"
        },
        {
            "CVE-ID": "CVE-2022-43945",
            "CVE-Description": "The Linux kernel NFSD implementation prior to versions 5.19.17 and 6.0.2 are vulnerable to buffer overflow. NFSD tracks the number of pages held by each NFSD thread by combining the receive and send buffers of a remote procedure call (RPC) into a single array of pages. A client can force the send buffer to shrink by sending an RPC message over TCP with garbage data added at the end of the message. The RPC message with garbage data is still correctly formed according to the specification and is passed forward to handlers. Vulnerable code in NFSD is not expecting the oversized request and writes beyond the allocated buffer space. CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
            "Severity": "HIGH",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 263,
            "CAPEC Description": "This describes an attack where an application is forced to use a file that an attacker has corrupted. The result is often a denial of service caused by the application being unable to process the corrupted file, but other results, including the disabling of filters or access controls (if the application fails in an unsafe way rather than failing by locking down) or buffer overflows are possible.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2024-26952",
            "CVE-Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nksmbd: fix potencial out-of-bounds when buffer offset is invalid\n\nI found potencial out-of-bounds when buffer offset fields of a few requests\nis invalid. This patch set the minimum value of buffer offset field to\n->Buffer offset to validate buffer length.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 586,
            "CAPEC Description": "An adversary attempts to exploit an application by injecting additional, malicious content during its processing of serialized objects. Developers leverage serialization in order to convert data or state into a static, binary format for saving to disk or transferring over a network. These objects are then deserialized when needed to recover the data/state. By injecting a malformed object into a vulnerable application, an adversary can potentially compromise the application by manipulating the deserialization process. This can result in a number of unwanted outcomes, including remote code execution.",
            "Original CWE-ID": "CWE-120",
            "Original CAPEC-ID": "100, 92, 9, 14, 47, 24, 10, 44, 8, 67, 42, 45, 46"
        },
        {
            "CVE-ID": "CVE-2021-3669",
            "CVE-Description": "A flaw was found in the Linux kernel. Measuring usage of the shared memory does not scale with large shared memory segment counts which could lead to resource exhaustion and DoS.",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 770,
            "CWE Description": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
            "Mapped CAPEC-ID": 487,
            "CAPEC Description": "An adversary may execute a flooding attack using the ICMP protocol with the intent to deny legitimate users access to a service by consuming the available network bandwidth. A typical attack involves a victim server receiving ICMP packets at a high rate from a wide range of source addresses. Additionally, due to the session-less nature of the ICMP protocol, the source of a packet is easily spoofed making it difficult to find the source of the attack.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2022-0480",
            "CVE-Description": "A flaw was found in the filelock_init in fs/locks.c function in the Linux kernel. This issue can lead to host memory exhaustion due to memcg not limiting the number of Portable Operating System Interface (POSIX) file locks.",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 491,
            "CAPEC Description": "An adversary exploits macro-like substitution to cause a denial of service situation due to excessive memory being allocated to fully expand the data. The result of this denial of service could cause the application to freeze or crash. This involves defining a very large entity and using it multiple times in a single entity substitution. CAPEC-197 is a similar attack pattern, but it is easier to discover and defend against. This attack pattern does not perform multi-level substitution and therefore does not obviously appear to consume extensive resources.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2024-36938",
            "CVE-Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf, skmsg: Fix NULL pointer dereference in sk_psock_skb_ingress_enqueue\n\nFix NULL pointer data-races in sk_psock_skb_ingress_enqueue() which\nsyzbot reported [1].\n\n[1]\nBUG: KCSAN: data-race in sk_psock_drop / sk_psock_skb_ingress_enqueue\n\nwrite to 0xffff88814b3278b8 of 8 bytes by task 10724 on cpu 1:\n sk_psock_stop_verdict net/core/skmsg.c:1257 [inline]\n sk_psock_drop+0x13e/0x1f0 net/core/skmsg.c:843\n sk_psock_put include/linux/skmsg.h:459 [inline]\n sock_map_close+0x1a7/0x260 net/core/sock_map.c:1648\n unix_release+0x4b/0x80 net/unix/af_unix.c:1048\n __sock_release net/socket.c:659 [inline]\n sock_close+0x68/0x150 net/socket.c:1421\n __fput+0x2c1/0x660 fs/file_table.c:422\n __fput_sync+0x44/0x60 fs/file_table.c:507\n __do_sys_close fs/open.c:1556 [inline]\n __se_sys_close+0x101/0x1b0 fs/open.c:1541\n __x64_sys_close+0x1f/0x30 fs/open.c:1541\n do_syscall_64+0xd3/0x1d0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\nread to 0xffff88814b3278b8 of 8 bytes by task 10713 on cpu 0:\n sk_psock_data_ready include/linux/skmsg.h:464 [inline]\n sk_psock_skb_ingress_enqueue+0x32d/0x390 net/core/skmsg.c:555\n sk_psock_skb_ingress_self+0x185/0x1e0 net/core/skmsg.c:606\n sk_psock_verdict_apply net/core/skmsg.c:1008 [inline]\n sk_psock_verdict_recv+0x3e4/0x4a0 net/core/skmsg.c:1202\n unix_read_skb net/unix/af_unix.c:2546 [inline]\n unix_stream_read_skb+0x9e/0xf0 net/unix/af_unix.c:2682\n sk_psock_verdict_data_ready+0x77/0x220 net/core/skmsg.c:1223\n unix_stream_sendmsg+0x527/0x860 net/unix/af_unix.c:2339\n sock_sendmsg_nosec net/socket.c:730 [inline]\n __sock_sendmsg+0x140/0x180 net/socket.c:745\n ____sys_sendmsg+0x312/0x410 net/socket.c:2584\n ___sys_sendmsg net/socket.c:2638 [inline]\n __sys_sendmsg+0x1e9/0x280 net/socket.c:2667\n __do_sys_sendmsg net/socket.c:2676 [inline]\n __se_sys_sendmsg net/socket.c:2674 [inline]\n __x64_sys_sendmsg+0x46/0x50 net/socket.c:2674\n do_syscall_64+0xd3/0x1d0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\nvalue changed: 0xffffffff83d7feb0 -> 0x0000000000000000\n\nReported by Kernel Concurrency Sanitizer on:\nCPU: 0 PID: 10713 Comm: syz-executor.4 Tainted: G        W          6.8.0-syzkaller-08951-gfe46a7dd189e #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 02/29/2024\n\nPrior to this, commit 4cd12c6065df (\"bpf, sockmap: Fix NULL pointer\ndereference in sk_psock_verdict_data_ready()\") fixed one NULL pointer\nsimilarly due to no protection of saved_data_ready. Here is another\ndifferent caller causing the same issue because of the same reason. So\nwe should protect it with sk_callback_lock read lock because the writer\nside in the sk_psock_drop() uses \"write_lock_bh(&sk->sk_callback_lock);\".\n\nTo avoid errors that could happen in future, I move those two pairs of\nlock into the sk_psock_data_ready(), which is suggested by John Fastabend.",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 15,
            "CWE Description": "One or more system settings or configuration elements can be externally controlled by a user.",
            "Mapped CAPEC-ID": 1,
            "CAPEC Description": "In applications, particularly web applications, access to functionality is mitigated by an authorization framework. This framework maps Access Control Lists (ACLs) to elements of the application's functionality; particularly URL's for web apps. In the case that the administrator failed to specify an ACL for a particular element, an attacker may be able to access it with impunity. An attacker with the ability to access functionality not properly constrained by ACLs can obtain sensitive information and possibly compromise the entire application. Such an attacker can access resources that must be available only to users at a higher privilege level, can access management sections of the application, or can run queries for data that they otherwise not supposed to.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2018-12928",
            "CVE-Description": "In the Linux kernel 4.15.0, a NULL pointer dereference was discovered in hfs_ext_read_extent in hfs.ko. This can occur during a mount of a crafted hfs filesystem.",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2019-12378",
            "CVE-Description": "An issue was discovered in ip6_ra_control in net/ipv6/ipv6_sockglue.c in the Linux kernel through 5.1.5. There is an unchecked kmalloc of new_ra, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: This has been disputed as not an issue",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2019-12381",
            "CVE-Description": "An issue was discovered in ip_ra_control in net/ipv4/ip_sockglue.c in the Linux kernel through 5.1.5. There is an unchecked kmalloc of new_ra, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: this is disputed because new_ra is never used if it is NULL",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 129,
            "CAPEC Description": "This attack pattern involves an adversary manipulating a pointer within a target application resulting in the application accessing an unintended memory location. This can result in the crashing of the application or, for certain pointer values, access to data that would not normally be possible or the execution of arbitrary code. Since pointers are simply integer variables, Integer Attacks may often be used in Pointer Attacks.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2019-12382",
            "CVE-Description": "An issue was discovered in drm_load_edid_firmware in drivers/gpu/drm/drm_edid_load.c in the Linux kernel through 5.1.5. There is an unchecked kstrdup of fwstr, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: The vendor disputes this issues as not being a vulnerability because kstrdup() returning NULL is handled sufficiently and there is no chance for a NULL pointer dereference",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 487,
            "CAPEC Description": "An adversary may execute a flooding attack using the ICMP protocol with the intent to deny legitimate users access to a service by consuming the available network bandwidth. A typical attack involves a victim server receiving ICMP packets at a high rate from a wide range of source addresses. Additionally, due to the session-less nature of the ICMP protocol, the source of a packet is easily spoofed making it difficult to find the source of the attack.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2019-12455",
            "CVE-Description": "An issue was discovered in sunxi_divs_clk_setup in drivers/clk/sunxi/clk-sunxi.c in the Linux kernel through 5.1.5. There is an unchecked kstrndup of derived_name, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: This id is disputed as not being an issue because \u201cThe memory allocation that was not checked is part of a code that only runs at boot time, before user processes are started. Therefore, there is no possibility for an unprivileged user to control it, and no denial of service.\u201d",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 129,
            "CAPEC Description": "This attack pattern involves an adversary manipulating a pointer within a target application resulting in the application accessing an unintended memory location. This can result in the crashing of the application or, for certain pointer values, access to data that would not normally be possible or the execution of arbitrary code. Since pointers are simply integer variables, Integer Attacks may often be used in Pointer Attacks.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2019-16229",
            "CVE-Description": "drivers/gpu/drm/amd/amdkfd/kfd_interrupt.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference. NOTE: The security community disputes this issues as not being serious enough to be deserving a CVE id",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2019-16230",
            "CVE-Description": "drivers/gpu/drm/radeon/radeon_display.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference. NOTE: A third-party software maintainer states that the work queue allocation is happening during device initialization, which for a graphics card occurs during boot. It is not attacker controllable and OOM at that time is highly unlikely",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 129,
            "CAPEC Description": "This attack pattern involves an adversary manipulating a pointer within a target application resulting in the application accessing an unintended memory location. This can result in the crashing of the application or, for certain pointer values, access to data that would not normally be possible or the execution of arbitrary code. Since pointers are simply integer variables, Integer Attacks may often be used in Pointer Attacks.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2019-16231",
            "CVE-Description": "drivers/net/fjes/fjes_main.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2019-16232",
            "CVE-Description": "drivers/net/wireless/marvell/libertas/if_sdio.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2019-16233",
            "CVE-Description": "drivers/scsi/qla2xxx/qla_os.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2019-16234",
            "CVE-Description": "drivers/net/wireless/intel/iwlwifi/pcie/trans.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2019-19378",
            "CVE-Description": "In the Linux kernel 5.0.21, mounting a crafted btrfs filesystem image can lead to slab-out-of-bounds write access in index_rbio_pages in fs/btrfs/raid56.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 209,
            "CAPEC Description": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-32078",
            "CVE-Description": "An Out-of-Bounds Read was discovered in arch/arm/mach-footbridge/personal-pci.c in the Linux kernel through 5.12.11 because of the lack of a check for a value that shouldn't be negative, e.g., access to element -2 of an array, aka CID-298a58e165e4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2023-1075",
            "CVE-Description": "A flaw was found in the Linux Kernel. The tls_is_tx_ready() incorrectly checks for list emptiness, potentially accessing a type confused entry to the list_head, leaking the last byte of the confused field that overlaps with rec->tx_ready.",
            "Severity": "LOW",
            "Mapped CWE-ID": 843,
            "CWE Description": "The product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.",
            "Mapped CAPEC-ID": 209,
            "CAPEC Description": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.",
            "Original CWE-ID": "CWE-843",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-23003",
            "CVE-Description": "In the Linux kernel before 5.16, tools/perf/util/expr.c lacks a check for the hashmap__new return value.",
            "Severity": "LOW",
            "Mapped CWE-ID": 252,
            "CWE Description": "The product does not check the return value from a method or function, which can prevent it from detecting unexpected states and conditions.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-252",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-26242",
            "CVE-Description": "afu_mmio_region_get_by_offset in drivers/fpga/dfl-afu-region.c in the Linux kernel through 6.1.12 has an integer overflow.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2023-31081",
            "CVE-Description": "An issue was discovered in drivers/media/test-drivers/vidtv/vidtv_bridge.c in the Linux kernel 6.2. There is a NULL pointer dereference in vidtv_mux_stop_thread. In vidtv_stop_streaming, after dvb->mux=NULL occurs, it executes vidtv_mux_stop_thread(dvb->mux).",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 129,
            "CAPEC Description": "This attack pattern involves an adversary manipulating a pointer within a target application resulting in the application accessing an unintended memory location. This can result in the crashing of the application or, for certain pointer values, access to data that would not normally be possible or the execution of arbitrary code. Since pointers are simply integer variables, Integer Attacks may often be used in Pointer Attacks.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-6610",
            "CVE-Description": "An out-of-bounds read vulnerability was found in smb2_dump_detail in fs/smb/client/smb2ops.c in the Linux Kernel. This issue could allow a local attacker to crash the system or leak internal kernel information.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2013-4235",
            "CVE-Description": "shadow: TOCTOU (time-of-check time-of-use) race condition when copying and removing directory trees",
            "Severity": "LOW",
            "Mapped CWE-ID": 367,
            "CWE Description": "The product checks the state of a resource before using that resource, but the resource's state can change between the check and the use in a way that invalidates the results of the check. This can cause the product to perform invalid actions when the resource is in an unexpected state.",
            "Mapped CAPEC-ID": 463,
            "CAPEC Description": "An adversary is able to efficiently decrypt data without knowing the decryption key if a target system leaks data on whether or not a padding error happened while decrypting the ciphertext. A target system that leaks this type of information becomes the padding oracle and an adversary is able to make use of that oracle to efficiently decrypt data without knowing the decryption key by issuing on average 128*b calls to the padding oracle (where b is the number of bytes in the ciphertext block). In addition to performing decryption, an adversary is also able to produce valid ciphertexts (i.e., perform encryption) by using the padding oracle, all without knowing the encryption key.",
            "Original CWE-ID": "CWE-367",
            "Original CAPEC-ID": "27, 29"
        },
        {
            "CVE-ID": "CVE-2022-1304",
            "CVE-Description": "An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2022-0563",
            "CVE-Description": "A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 22,
            "CWE Description": "The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",
            "Mapped CAPEC-ID": 579,
            "CAPEC Description": "Winlogon is a part of Windows that performs logon actions. In Windows systems prior to Windows Vista, a registry key can be modified that causes Winlogon to load a DLL on startup. Adversaries may take advantage of this feature to load adversarial code at startup.",
            "Original CWE-ID": "CWE-209",
            "Original CAPEC-ID": "463, 215, 7, 54"
        },
        {
            "CVE-ID": "CVE-2013-4235",
            "CVE-Description": "shadow: TOCTOU (time-of-check time-of-use) race condition when copying and removing directory trees",
            "Severity": "LOW",
            "Mapped CWE-ID": 367,
            "CWE Description": "The product checks the state of a resource before using that resource, but the resource's state can change between the check and the use in a way that invalidates the results of the check. This can cause the product to perform invalid actions when the resource is in an unexpected state.",
            "Mapped CAPEC-ID": 463,
            "CAPEC Description": "An adversary is able to efficiently decrypt data without knowing the decryption key if a target system leaks data on whether or not a padding error happened while decrypting the ciphertext. A target system that leaks this type of information becomes the padding oracle and an adversary is able to make use of that oracle to efficiently decrypt data without knowing the decryption key by issuing on average 128*b calls to the padding oracle (where b is the number of bytes in the ciphertext block). In addition to performing decryption, an adversary is also able to produce valid ciphertexts (i.e., perform encryption) by using the padding oracle, all without knowing the encryption key.",
            "Original CWE-ID": "CWE-367",
            "Original CAPEC-ID": "27, 29"
        },
        {
            "CVE-ID": "CVE-2020-16156",
            "CVE-Description": "CPAN 2.28 allows Signature Verification Bypass.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 347,
            "CWE Description": "The product does not verify, or incorrectly verifies, the cryptographic signature for data.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-347",
            "Original CAPEC-ID": "475, 463"
        },
        {
            "CVE-ID": "CVE-2023-31484",
            "CVE-Description": "CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 295,
            "CWE Description": "The product does not validate, or incorrectly validates, a certificate.",
            "Mapped CAPEC-ID": 661,
            "CAPEC Description": "An adversary inserts a debugger into the program entry point of a mobile application to modify the application binary, with the goal of evading Root/Jailbreak detection. Mobile device users often Root/Jailbreak their devices in order to gain administrative control over the mobile operating system and/or to install third-party mobile applications that are not provided by authorized application stores (e.g. Google Play Store and Apple App Store). Rooting/Jailbreaking a mobile device also provides users with access to system debuggers and disassemblers, which can be leveraged to exploit applications by dumping the application's memory at runtime in order to remove or bypass signature verification methods. This further allows the adversary to evade Root/Jailbreak detection mechanisms, which can result in execution of administrative commands, obtaining confidential data, impersonating legitimate users of the application, and more.",
            "Original CWE-ID": "CWE-295",
            "Original CAPEC-ID": "475, 459"
        },
        {
            "CVE-ID": "CVE-2023-47038",
            "CVE-Description": "A vulnerability was found in perl 5.30.0 through 5.38.0. This issue occurs when a crafted regular expression is compiled by perl, which can allow an attacker controlled byte buffer overflow in a heap allocated buffer.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2011-4116",
            "CVE-Description": "_is_safe in the File::Temp module for Perl does not properly handle symlinks.",
            "Severity": "LOW",
            "Mapped CWE-ID": 79,
            "CWE Description": "The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2023-31486",
            "CVE-Description": "HTTP::Tiny before 0.083, a Perl core module since 5.13.9 and available standalone on CPAN, has an insecure default TLS configuration where users must opt in to verify certificates.",
            "Severity": "LOW",
            "Mapped CWE-ID": 306,
            "CWE Description": "The product does not perform any authentication for functionality that requires a provable user identity or consumes a significant amount of resources.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-295",
            "Original CAPEC-ID": "475, 459"
        },
        {
            "CVE-ID": "CVE-2020-16156",
            "CVE-Description": "CPAN 2.28 allows Signature Verification Bypass.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 347,
            "CWE Description": "The product does not verify, or incorrectly verifies, the cryptographic signature for data.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-347",
            "Original CAPEC-ID": "475, 463"
        },
        {
            "CVE-ID": "CVE-2023-31484",
            "CVE-Description": "CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 295,
            "CWE Description": "The product does not validate, or incorrectly validates, a certificate.",
            "Mapped CAPEC-ID": 661,
            "CAPEC Description": "An adversary inserts a debugger into the program entry point of a mobile application to modify the application binary, with the goal of evading Root/Jailbreak detection. Mobile device users often Root/Jailbreak their devices in order to gain administrative control over the mobile operating system and/or to install third-party mobile applications that are not provided by authorized application stores (e.g. Google Play Store and Apple App Store). Rooting/Jailbreaking a mobile device also provides users with access to system debuggers and disassemblers, which can be leveraged to exploit applications by dumping the application's memory at runtime in order to remove or bypass signature verification methods. This further allows the adversary to evade Root/Jailbreak detection mechanisms, which can result in execution of administrative commands, obtaining confidential data, impersonating legitimate users of the application, and more.",
            "Original CWE-ID": "CWE-295",
            "Original CAPEC-ID": "475, 459"
        },
        {
            "CVE-ID": "CVE-2023-47038",
            "CVE-Description": "A vulnerability was found in perl 5.30.0 through 5.38.0. This issue occurs when a crafted regular expression is compiled by perl, which can allow an attacker controlled byte buffer overflow in a heap allocated buffer.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2011-4116",
            "CVE-Description": "_is_safe in the File::Temp module for Perl does not properly handle symlinks.",
            "Severity": "LOW",
            "Mapped CWE-ID": 79,
            "CWE Description": "The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2023-31486",
            "CVE-Description": "HTTP::Tiny before 0.083, a Perl core module since 5.13.9 and available standalone on CPAN, has an insecure default TLS configuration where users must opt in to verify certificates.",
            "Severity": "LOW",
            "Mapped CWE-ID": 306,
            "CWE Description": "The product does not perform any authentication for functionality that requires a provable user identity or consumes a significant amount of resources.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-295",
            "Original CAPEC-ID": "475, 459"
        },
        {
            "CVE-ID": "CVE-2020-16156",
            "CVE-Description": "CPAN 2.28 allows Signature Verification Bypass.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 347,
            "CWE Description": "The product does not verify, or incorrectly verifies, the cryptographic signature for data.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-347",
            "Original CAPEC-ID": "475, 463"
        },
        {
            "CVE-ID": "CVE-2023-31484",
            "CVE-Description": "CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 295,
            "CWE Description": "The product does not validate, or incorrectly validates, a certificate.",
            "Mapped CAPEC-ID": 661,
            "CAPEC Description": "An adversary inserts a debugger into the program entry point of a mobile application to modify the application binary, with the goal of evading Root/Jailbreak detection. Mobile device users often Root/Jailbreak their devices in order to gain administrative control over the mobile operating system and/or to install third-party mobile applications that are not provided by authorized application stores (e.g. Google Play Store and Apple App Store). Rooting/Jailbreaking a mobile device also provides users with access to system debuggers and disassemblers, which can be leveraged to exploit applications by dumping the application's memory at runtime in order to remove or bypass signature verification methods. This further allows the adversary to evade Root/Jailbreak detection mechanisms, which can result in execution of administrative commands, obtaining confidential data, impersonating legitimate users of the application, and more.",
            "Original CWE-ID": "CWE-295",
            "Original CAPEC-ID": "475, 459"
        },
        {
            "CVE-ID": "CVE-2023-47038",
            "CVE-Description": "A vulnerability was found in perl 5.30.0 through 5.38.0. This issue occurs when a crafted regular expression is compiled by perl, which can allow an attacker controlled byte buffer overflow in a heap allocated buffer.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2011-4116",
            "CVE-Description": "_is_safe in the File::Temp module for Perl does not properly handle symlinks.",
            "Severity": "LOW",
            "Mapped CWE-ID": 79,
            "CWE Description": "The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2023-31486",
            "CVE-Description": "HTTP::Tiny before 0.083, a Perl core module since 5.13.9 and available standalone on CPAN, has an insecure default TLS configuration where users must opt in to verify certificates.",
            "Severity": "LOW",
            "Mapped CWE-ID": 306,
            "CWE Description": "The product does not perform any authentication for functionality that requires a provable user identity or consumes a significant amount of resources.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-295",
            "Original CAPEC-ID": "475, 459"
        },
        {
            "CVE-ID": "CVE-2023-4016",
            "CVE-Description": "Under some circumstances, this weakness allows a user who has access to run the \u201cps\u201d utility on a machine, the ability to write almost unlimited amounts of unfiltered data into the process heap.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-28861",
            "CVE-Description": "Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states \"Warning: http.server is not recommended for production. It only implements basic security checks.\"",
            "Severity": "LOW",
            "Mapped CWE-ID": 601,
            "CWE Description": "A web application accepts a user-controlled input that specifies a link to an external site, and uses that link in a Redirect. This simplifies phishing attacks.",
            "Mapped CAPEC-ID": 178,
            "CAPEC Description": "An attacker is able to trick the victim into executing a Flash document that passes commands or calls to a Flash player browser plugin, allowing the attacker to exploit native Flash functionality in the client browser. This attack pattern occurs where an attacker can provide a crafted link to a Flash document (SWF file) which, when followed, will cause additional malicious instructions to be executed. The attacker does not need to serve or control the Flash document. The attack takes advantage of the fact that Flash files can reference external URLs. If variables that serve as URLs that the Flash application references can be controlled through parameters, then by creating a link that includes values for those parameters, an attacker can cause arbitrary content to be referenced and possibly executed by the targeted Flash application.",
            "Original CWE-ID": "CWE-601",
            "Original CAPEC-ID": "178"
        },
        {
            "CVE-ID": "CVE-2022-37454",
            "CVE-Description": "The Keccak XKCP SHA-3 reference implementation before fdc6fef has an integer overflow and resultant buffer overflow that allows attackers to execute arbitrary code or eliminate expected cryptographic properties. This occurs in the sponge function interface.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2021-28861",
            "CVE-Description": "Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states \"Warning: http.server is not recommended for production. It only implements basic security checks.\"",
            "Severity": "LOW",
            "Mapped CWE-ID": 601,
            "CWE Description": "A web application accepts a user-controlled input that specifies a link to an external site, and uses that link in a Redirect. This simplifies phishing attacks.",
            "Mapped CAPEC-ID": 178,
            "CAPEC Description": "An attacker is able to trick the victim into executing a Flash document that passes commands or calls to a Flash player browser plugin, allowing the attacker to exploit native Flash functionality in the client browser. This attack pattern occurs where an attacker can provide a crafted link to a Flash document (SWF file) which, when followed, will cause additional malicious instructions to be executed. The attacker does not need to serve or control the Flash document. The attack takes advantage of the fact that Flash files can reference external URLs. If variables that serve as URLs that the Flash application references can be controlled through parameters, then by creating a link that includes values for those parameters, an attacker can cause arbitrary content to be referenced and possibly executed by the targeted Flash application.",
            "Original CWE-ID": "CWE-601",
            "Original CAPEC-ID": "178"
        },
        {
            "CVE-ID": "CVE-2022-37454",
            "CVE-Description": "The Keccak XKCP SHA-3 reference implementation before fdc6fef has an integer overflow and resultant buffer overflow that allows attackers to execute arbitrary code or eliminate expected cryptographic properties. This occurs in the sponge function interface.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2022-0563",
            "CVE-Description": "A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 22,
            "CWE Description": "The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",
            "Mapped CAPEC-ID": 579,
            "CAPEC Description": "Winlogon is a part of Windows that performs logon actions. In Windows systems prior to Windows Vista, a registry key can be modified that causes Winlogon to load a DLL on startup. Adversaries may take advantage of this feature to load adversarial code at startup.",
            "Original CWE-ID": "CWE-209",
            "Original CAPEC-ID": "463, 215, 7, 54"
        },
        {
            "CVE-ID": "CVE-2023-28859",
            "CVE-Description": "redis-py before 4.4.4 and 4.5.x before 4.5.4 leaves a connection open after canceling an async Redis command at an inopportune time, and can send response data to the client of an unrelated request. (This could, for example, happen for a non-pipeline operation.) NOTE: the solutions for CVE-2023-28859 address data leakage across AsyncIO connections in general.",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 78,
            "CWE Description": "The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",
            "Mapped CAPEC-ID": 209,
            "CAPEC Description": "An adversary creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. The adversary tricks the victim into accessing a URL that responds with the script file. Some browsers will detect that the specified MIME type of the file does not match the actual type of its content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the adversary's script may run on the target unsanitized, possibly revealing the victim's cookies or executing arbitrary script in their browser.",
            "Original CWE-ID": "CWE-459",
            "Original CAPEC-ID": "N/A"
        }
    ],
    "statistics": {
        "severity_accuracy": {
            "LOW": 0.7589285714285714,
            "MEDIUM": 0.4166666666666667,
            "HIGH": 0.5,
            "CRITICAL": 1.0
        },
        "overall_accuracy": 0.7191011235955056,
        "non_2023_accuracy": 0.6802030456852792,
        "severity_count": {
            "LOW": 224,
            "MEDIUM": 12,
            "HIGH": 28,
            "CRITICAL": 3
        },
        "capec_accuracy": 0.49640287769784175
    }
}