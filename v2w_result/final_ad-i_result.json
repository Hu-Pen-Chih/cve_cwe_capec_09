{
    "results": [
        {
            "CVE-ID": "CVE-2011-3374",
            "CVE-Description": "It was found that apt-key in apt, all versions, do not correctly validate gpg keys with the master keyring, leading to a potential man-in-the-middle attack.",
            "Severity": "LOW",
            "Mapped CWE-ID": 295,
            "CWE Description": "The product does not validate, or incorrectly validates, a certificate.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-347",
            "Original CAPEC-ID": "475, 463"
        },
        {
            "CVE-ID": "CVE-2022-3715",
            "CVE-Description": "A flaw was found in the bash package, where a heap-buffer overflow can occur in valid parameter_transform. This issue may lead to memory problems.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 44,
            "CAPEC Description": "An attack of this type exploits a buffer overflow vulnerability in the handling of binary resources. Binary resources may include music files like MP3, image files like JPEG files, and any other binary file. These attacks may pass unnoticed to the client machine through normal usage of files, such as a browser loading a seemingly innocent JPEG file. This can allow the adversary access to the execution stack and execute arbitrary code in the target process.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2017-13716",
            "CVE-Description": "The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).",
            "Severity": "LOW",
            "Mapped CWE-ID": 1333,
            "CWE Description": "The product uses a regular expression with an inefficient, possibly exponential worst-case computational complexity that consumes excessive CPU cycles.",
            "Mapped CAPEC-ID": 26,
            "CAPEC Description": "The adversary targets a race condition occurring when multiple processes access and manipulate the same resource concurrently, and the outcome of the execution depends on the particular order in which the access takes place. The adversary can leverage a race condition by running the race, modifying the resource and modifying the normal execution flow. For instance, a race condition can occur while accessing a file: the adversary can trick the system by replacing the original file with their version and cause the system to read the malicious file.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2018-18483",
            "CVE-Description": "The get_count function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31, allows remote attackers to cause a denial of service (malloc called with the result of an integer-overflowing calculation) or possibly have unspecified other impact via a crafted string, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 191,
            "CWE Description": "The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.",
            "Mapped CAPEC-ID": 67,
            "CAPEC Description": "This attack targets applications and software that uses the syslog() function insecurely. If an application does not explicitely use a format string parameter in a call to syslog(), user input can be placed in the format string parameter leading to a format string injection attack. Adversaries can then inject malicious format string commands into the function call leading to a buffer overflow. There are many reported software vulnerabilities with the root cause being a misuse of the syslog() function.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20673",
            "CVE-Description": "The demangle_template function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31.1, contains an integer overflow vulnerability (for \"Create an array for saving the template argument values\") that can trigger a heap-based buffer overflow, as demonstrated by nm.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20712",
            "CVE-Description": "A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty, as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults, leading to denial-of-service, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2019-1010204",
            "CVE-Description": "GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation, Signed/Unsigned Comparison, Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497, elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2020-35448",
            "CVE-Description": "An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 67,
            "CAPEC Description": "This attack targets applications and software that uses the syslog() function insecurely. If an application does not explicitely use a format string parameter in a call to syslog(), user input can be placed in the format string parameter leading to a format string injection attack. Adversaries can then inject malicious format string commands into the function call leading to a buffer overflow. There are many reported software vulnerabilities with the root cause being a misuse of the syslog() function.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2021-20197",
            "CVE-Description": "There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar, objcopy, strip, ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users), an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.",
            "Severity": "LOW",
            "Mapped CWE-ID": 364,
            "CWE Description": "The product uses a signal handler that introduces a race condition.",
            "Mapped CAPEC-ID": 26,
            "CAPEC Description": "The adversary targets a race condition occurring when multiple processes access and manipulate the same resource concurrently, and the outcome of the execution depends on the particular order in which the access takes place. The adversary can leverage a race condition by running the race, modifying the resource and modifying the normal execution flow. For instance, a race condition can occur while accessing a file: the adversary can trick the system by replacing the original file with their version and cause the system to read the malicious file.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2021-32256",
            "CVE-Description": "An issue was discovered in GNU libiberty, as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-3549",
            "CVE-Description": "An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 126,
            "CAPEC Description": "An adversary uses path manipulation methods to exploit insufficient input validation of a target to obtain access to data that should be not be retrievable by ordinary well-formed requests. A typical variety of this attack involves specifying a path to a desired file together with dot-dot-slash characters, resulting in the file access API or function traversing out of the intended directory structure and into the root file system. By replacing or modifying the expected path information the access function or API retrieves the file desired by the attacker. These attacks either involve the attacker providing a complete path to a targeted file or using control characters (e.g. path separators (/ or ) and/or dots (.)) to reach desired directories or files.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-45078",
            "CVE-Description": "stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact, as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 44,
            "CAPEC Description": "An attack of this type exploits a buffer overflow vulnerability in the handling of binary resources. Binary resources may include music files like MP3, image files like JPEG files, and any other binary file. These attacks may pass unnoticed to the client machine through normal usage of files, such as a browser loading a seemingly innocent JPEG file. This can allow the adversary access to the execution stack and execute arbitrary code in the target process.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-46174",
            "CVE-Description": "Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35205",
            "CVE-Description": "An issue was discovered in Binutils readelf 2.38.50, reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 617,
            "CWE Description": "The product contains an assert() or similar statement that can be triggered by an attacker, which leads to an application exit or other behavior that is more severe than necessary.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-617",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35206",
            "CVE-Description": "Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-38533",
            "CVE-Description": "In GNU Binutils before 2.40, there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-4285",
            "CVE-Description": "An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-44840",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-45703",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-47673",
            "CVE-Description": "An issue was discovered in Binutils addr2line before 2.39.3, function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2022-48064",
            "CVE-Description": "GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2023-1579",
            "CVE-Description": "Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-1972",
            "CVE-Description": "A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25584",
            "CVE-Description": "An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2023-25585",
            "CVE-Description": "A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25586",
            "CVE-Description": "A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25588",
            "CVE-Description": "A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function, which may lead to an application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2017-13716",
            "CVE-Description": "The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).",
            "Severity": "LOW",
            "Mapped CWE-ID": 1333,
            "CWE Description": "The product uses a regular expression with an inefficient, possibly exponential worst-case computational complexity that consumes excessive CPU cycles.",
            "Mapped CAPEC-ID": 26,
            "CAPEC Description": "The adversary targets a race condition occurring when multiple processes access and manipulate the same resource concurrently, and the outcome of the execution depends on the particular order in which the access takes place. The adversary can leverage a race condition by running the race, modifying the resource and modifying the normal execution flow. For instance, a race condition can occur while accessing a file: the adversary can trick the system by replacing the original file with their version and cause the system to read the malicious file.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2018-18483",
            "CVE-Description": "The get_count function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31, allows remote attackers to cause a denial of service (malloc called with the result of an integer-overflowing calculation) or possibly have unspecified other impact via a crafted string, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 191,
            "CWE Description": "The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.",
            "Mapped CAPEC-ID": 67,
            "CAPEC Description": "This attack targets applications and software that uses the syslog() function insecurely. If an application does not explicitely use a format string parameter in a call to syslog(), user input can be placed in the format string parameter leading to a format string injection attack. Adversaries can then inject malicious format string commands into the function call leading to a buffer overflow. There are many reported software vulnerabilities with the root cause being a misuse of the syslog() function.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20673",
            "CVE-Description": "The demangle_template function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31.1, contains an integer overflow vulnerability (for \"Create an array for saving the template argument values\") that can trigger a heap-based buffer overflow, as demonstrated by nm.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20712",
            "CVE-Description": "A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty, as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults, leading to denial-of-service, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2019-1010204",
            "CVE-Description": "GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation, Signed/Unsigned Comparison, Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497, elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2020-35448",
            "CVE-Description": "An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 67,
            "CAPEC Description": "This attack targets applications and software that uses the syslog() function insecurely. If an application does not explicitely use a format string parameter in a call to syslog(), user input can be placed in the format string parameter leading to a format string injection attack. Adversaries can then inject malicious format string commands into the function call leading to a buffer overflow. There are many reported software vulnerabilities with the root cause being a misuse of the syslog() function.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2021-20197",
            "CVE-Description": "There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar, objcopy, strip, ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users), an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.",
            "Severity": "LOW",
            "Mapped CWE-ID": 364,
            "CWE Description": "The product uses a signal handler that introduces a race condition.",
            "Mapped CAPEC-ID": 26,
            "CAPEC Description": "The adversary targets a race condition occurring when multiple processes access and manipulate the same resource concurrently, and the outcome of the execution depends on the particular order in which the access takes place. The adversary can leverage a race condition by running the race, modifying the resource and modifying the normal execution flow. For instance, a race condition can occur while accessing a file: the adversary can trick the system by replacing the original file with their version and cause the system to read the malicious file.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2021-32256",
            "CVE-Description": "An issue was discovered in GNU libiberty, as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-3549",
            "CVE-Description": "An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 126,
            "CAPEC Description": "An adversary uses path manipulation methods to exploit insufficient input validation of a target to obtain access to data that should be not be retrievable by ordinary well-formed requests. A typical variety of this attack involves specifying a path to a desired file together with dot-dot-slash characters, resulting in the file access API or function traversing out of the intended directory structure and into the root file system. By replacing or modifying the expected path information the access function or API retrieves the file desired by the attacker. These attacks either involve the attacker providing a complete path to a targeted file or using control characters (e.g. path separators (/ or ) and/or dots (.)) to reach desired directories or files.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-45078",
            "CVE-Description": "stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact, as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 44,
            "CAPEC Description": "An attack of this type exploits a buffer overflow vulnerability in the handling of binary resources. Binary resources may include music files like MP3, image files like JPEG files, and any other binary file. These attacks may pass unnoticed to the client machine through normal usage of files, such as a browser loading a seemingly innocent JPEG file. This can allow the adversary access to the execution stack and execute arbitrary code in the target process.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-46174",
            "CVE-Description": "Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35205",
            "CVE-Description": "An issue was discovered in Binutils readelf 2.38.50, reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 617,
            "CWE Description": "The product contains an assert() or similar statement that can be triggered by an attacker, which leads to an application exit or other behavior that is more severe than necessary.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-617",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35206",
            "CVE-Description": "Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-38533",
            "CVE-Description": "In GNU Binutils before 2.40, there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-4285",
            "CVE-Description": "An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-44840",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-45703",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-47673",
            "CVE-Description": "An issue was discovered in Binutils addr2line before 2.39.3, function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2022-48064",
            "CVE-Description": "GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2023-1579",
            "CVE-Description": "Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-1972",
            "CVE-Description": "A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25584",
            "CVE-Description": "An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2023-25585",
            "CVE-Description": "A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25586",
            "CVE-Description": "A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25588",
            "CVE-Description": "A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function, which may lead to an application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2017-13716",
            "CVE-Description": "The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).",
            "Severity": "LOW",
            "Mapped CWE-ID": 1333,
            "CWE Description": "The product uses a regular expression with an inefficient, possibly exponential worst-case computational complexity that consumes excessive CPU cycles.",
            "Mapped CAPEC-ID": 26,
            "CAPEC Description": "The adversary targets a race condition occurring when multiple processes access and manipulate the same resource concurrently, and the outcome of the execution depends on the particular order in which the access takes place. The adversary can leverage a race condition by running the race, modifying the resource and modifying the normal execution flow. For instance, a race condition can occur while accessing a file: the adversary can trick the system by replacing the original file with their version and cause the system to read the malicious file.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2018-18483",
            "CVE-Description": "The get_count function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31, allows remote attackers to cause a denial of service (malloc called with the result of an integer-overflowing calculation) or possibly have unspecified other impact via a crafted string, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 191,
            "CWE Description": "The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.",
            "Mapped CAPEC-ID": 67,
            "CAPEC Description": "This attack targets applications and software that uses the syslog() function insecurely. If an application does not explicitely use a format string parameter in a call to syslog(), user input can be placed in the format string parameter leading to a format string injection attack. Adversaries can then inject malicious format string commands into the function call leading to a buffer overflow. There are many reported software vulnerabilities with the root cause being a misuse of the syslog() function.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20673",
            "CVE-Description": "The demangle_template function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31.1, contains an integer overflow vulnerability (for \"Create an array for saving the template argument values\") that can trigger a heap-based buffer overflow, as demonstrated by nm.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20712",
            "CVE-Description": "A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty, as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults, leading to denial-of-service, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2019-1010204",
            "CVE-Description": "GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation, Signed/Unsigned Comparison, Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497, elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2020-35448",
            "CVE-Description": "An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 67,
            "CAPEC Description": "This attack targets applications and software that uses the syslog() function insecurely. If an application does not explicitely use a format string parameter in a call to syslog(), user input can be placed in the format string parameter leading to a format string injection attack. Adversaries can then inject malicious format string commands into the function call leading to a buffer overflow. There are many reported software vulnerabilities with the root cause being a misuse of the syslog() function.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2021-20197",
            "CVE-Description": "There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar, objcopy, strip, ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users), an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.",
            "Severity": "LOW",
            "Mapped CWE-ID": 364,
            "CWE Description": "The product uses a signal handler that introduces a race condition.",
            "Mapped CAPEC-ID": 26,
            "CAPEC Description": "The adversary targets a race condition occurring when multiple processes access and manipulate the same resource concurrently, and the outcome of the execution depends on the particular order in which the access takes place. The adversary can leverage a race condition by running the race, modifying the resource and modifying the normal execution flow. For instance, a race condition can occur while accessing a file: the adversary can trick the system by replacing the original file with their version and cause the system to read the malicious file.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2021-32256",
            "CVE-Description": "An issue was discovered in GNU libiberty, as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-3549",
            "CVE-Description": "An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 126,
            "CAPEC Description": "An adversary uses path manipulation methods to exploit insufficient input validation of a target to obtain access to data that should be not be retrievable by ordinary well-formed requests. A typical variety of this attack involves specifying a path to a desired file together with dot-dot-slash characters, resulting in the file access API or function traversing out of the intended directory structure and into the root file system. By replacing or modifying the expected path information the access function or API retrieves the file desired by the attacker. These attacks either involve the attacker providing a complete path to a targeted file or using control characters (e.g. path separators (/ or ) and/or dots (.)) to reach desired directories or files.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-45078",
            "CVE-Description": "stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact, as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 44,
            "CAPEC Description": "An attack of this type exploits a buffer overflow vulnerability in the handling of binary resources. Binary resources may include music files like MP3, image files like JPEG files, and any other binary file. These attacks may pass unnoticed to the client machine through normal usage of files, such as a browser loading a seemingly innocent JPEG file. This can allow the adversary access to the execution stack and execute arbitrary code in the target process.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-46174",
            "CVE-Description": "Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35205",
            "CVE-Description": "An issue was discovered in Binutils readelf 2.38.50, reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 617,
            "CWE Description": "The product contains an assert() or similar statement that can be triggered by an attacker, which leads to an application exit or other behavior that is more severe than necessary.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-617",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35206",
            "CVE-Description": "Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-38533",
            "CVE-Description": "In GNU Binutils before 2.40, there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-4285",
            "CVE-Description": "An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-44840",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-45703",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-47673",
            "CVE-Description": "An issue was discovered in Binutils addr2line before 2.39.3, function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2022-48064",
            "CVE-Description": "GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2023-1579",
            "CVE-Description": "Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-1972",
            "CVE-Description": "A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25584",
            "CVE-Description": "An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2023-25585",
            "CVE-Description": "A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25586",
            "CVE-Description": "A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25588",
            "CVE-Description": "A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function, which may lead to an application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-0563",
            "CVE-Description": "A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 209,
            "CWE Description": "The product generates an error message that includes sensitive information about its environment, users, or associated data.",
            "Mapped CAPEC-ID": 87,
            "CAPEC Description": "An attacker employs forceful browsing (direct URL entry) to access portions of a website that are otherwise unreachable. Usually, a front controller or similar design pattern is employed to protect access to portions of a web application. Forceful browsing enables an attacker to access information, perform privileged operations and otherwise reach sections of the web application that have been improperly protected.",
            "Original CWE-ID": "CWE-209",
            "Original CAPEC-ID": "463, 215, 7, 54"
        },
        {
            "CVE-ID": "CVE-2022-1304",
            "CVE-Description": "An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 77,
            "CAPEC Description": "This attack targets user controlled variables (DEBUG=1, PHP Globals, and So Forth). An adversary can override variables leveraging user-supplied, untrusted query variables directly used on the application server without any data sanitization. In extreme cases, the adversary can change variables controlling the business logic of the application. For instance, in languages like PHP, a number of poorly set default configurations may allow the user to override variables.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2024-32002",
            "CVE-Description": "Git is a revision control system. Prior to versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4, repositories with submodules can be crafted in a way that exploits a bug in Git whereby it can be fooled into writing files not into the submodule's worktree but into a `.git/` directory. This allows writing a hook that will be executed while the clone operation is still running, giving the user no opportunity to inspect the code that is being executed. The problem has been patched in versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4. If symbolic link support is disabled in Git (e.g. via `git config --global core.symlinks false`), the described attack won't work. As always, it is best to avoid cloning repositories from untrusted sources.",
            "Severity": "CRITICAL",
            "Mapped CWE-ID": 15,
            "CWE Description": "One or more system settings or configuration elements can be externally controlled by a user.",
            "Mapped CAPEC-ID": 695,
            "CAPEC Description": "An adversary takes advantage of the redirect property of directly linked Version Control System (VCS) repositories to trick users into incorporating malicious code into their applications.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2024-32465",
            "CVE-Description": "Git is a revision control system. The Git project recommends to avoid working in untrusted repositories, and instead to clone it first with `git clone --no-local` to obtain a clean copy. Git has specific protections to make that a safe operation even with an untrusted source repository, but vulnerabilities allow those protections to be bypassed. In the context of cloning local repositories owned by other users, this vulnerability has been covered in CVE-2024-32004. But there are circumstances where the fixes for CVE-2024-32004 are not enough: For example, when obtaining a `.zip` file containing a full copy of a Git repository, it should not be trusted by default to be safe, as e.g. hooks could be configured to run within the context of that repository. The problem has been patched in versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4. As a workaround, avoid using Git in repositories that have been obtained via archives from untrusted sources.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 1123,
            "CWE Description": "The product uses too much self-modifying code.",
            "Mapped CAPEC-ID": 62,
            "CAPEC Description": "An attacker crafts malicious web links and distributes them (via web pages, email, etc.), typically in a targeted manner, hoping to induce users to click on the link and execute the malicious action against some third-party application. If successful, the action embedded in the malicious link will be processed and accepted by the targeted application with the users' privilege level. This type of attack leverages the persistence and implicit trust placed in user session cookies by many web applications today. In such an architecture, once the user authenticates to an application and a session cookie is created on the user's system, all following transactions for that session are authenticated using that cookie including potential actions initiated by an attacker and simply riding the existing session cookie.",
            "Original CWE-ID": "CWE-22",
            "Original CAPEC-ID": "126, 79, 76, 78, 64"
        },
        {
            "CVE-ID": "CVE-2023-25815",
            "CVE-Description": "In Git for Windows, the Windows port of Git, no localized messages are shipped with the installer. As a consequence, Git is expected not to localize messages at all, and skips the gettext initialization. However, due to a change in MINGW-packages, the `gettext()` function's implicit initialization no longer uses the runtime prefix but uses the hard-coded path `C:\\mingw64\\share\\locale` to look for localized messages. And since any authenticated user has the permission to create folders in `C:\\` (and since `C:\\mingw64` does not typically exist), it is possible for low-privilege users to place fake messages in that location where `git.exe` will pick them up in version 2.40.1.\n\nThis vulnerability is relatively hard to exploit and requires social engineering. For example, a legitimate message at the end of a clone could be maliciously modified to ask the user to direct their web browser to a malicious website, and the user might think that the message comes from Git and is legitimate. It does require local write access by the attacker, though, which makes this attack vector less likely. Version 2.40.1 contains a patch for this issue. Some workarounds are available. Do not work on a Windows machine with shared accounts, or alternatively create a `C:\\mingw64` folder and leave it empty. Users who have administrative rights may remove the permission to create folders in `C:\\`.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 145,
            "CAPEC Description": "An adversary spoofs a checksum message for the purpose of making a payload appear to have a valid corresponding checksum. Checksums are used to verify message integrity. They consist of some value based on the value of the message they are protecting. Hash codes are a common checksum mechanism. Both the sender and recipient are able to compute the checksum based on the contents of the message. If the message contents change between the sender and recipient, the sender and recipient will compute different checksum values. Since the sender's checksum value is transmitted with the message, the recipient would know that a modification occurred. In checksum spoofing an adversary modifies the message body and then modifies the corresponding checksum so that the recipient's checksum calculation will match the checksum (created by the adversary) in the message. This would prevent the recipient from realizing that a change occurred.",
            "Original CWE-ID": "CWE-134",
            "Original CAPEC-ID": "67, 135"
        },
        {
            "CVE-ID": "CVE-2024-32020",
            "CVE-Description": "Git is a revision control system. Prior to versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4, local clones may end up hardlinking files into the target repository's object database when source and target repository reside on the same disk. If the source repository is owned by a different user, then those hardlinked files may be rewritten at any point in time by the untrusted user. Cloning local repositories will cause Git to either copy or hardlink files of the source repository into the target repository. This significantly speeds up such local clones compared to doing a \"proper\" clone and saves both disk space and compute time. When cloning a repository located on the same disk that is owned by a different user than the current user we also end up creating such hardlinks. These files will continue to be owned and controlled by the potentially-untrusted user and can be rewritten by them at will in the future. The problem has been patched in versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 459,
            "CWE Description": "The product does not properly clean up and remove temporary or supporting resources after they have been used.",
            "Mapped CAPEC-ID": 27,
            "CAPEC Description": "This attack leverages the use of symbolic links (Symlinks) in order to write to sensitive files. An attacker can create a Symlink link to a target file not otherwise accessible to them. When the privileged program tries to create a temporary file with the same name as the Symlink link, it will actually write to the target file pointed to by the attackers' Symlink link. If the attacker can insert malicious content in the temporary file they will be writing to the sensitive file by using the Symlink. The race occurs because the system checks if the temporary file exists, then creates the file. The attacker would typically create the Symlink during the interval between the check and the creation of the temporary file.",
            "Original CWE-ID": "CWE-281",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2024-32021",
            "CVE-Description": "Git is a revision control system. Prior to versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4, when cloning a local source repository that contains symlinks via the filesystem, Git may create hardlinks to arbitrary user-readable files on the same filesystem as the target repository in the `objects/` directory. Cloning a local repository over the filesystem may creating hardlinks to arbitrary user-owned files on the same filesystem in the target Git repository's `objects/` directory. When cloning a repository over the filesystem (without explicitly specifying the `file://` protocol or `--no-local`), the optimizations for local cloning\nwill be used, which include attempting to hard link the object files instead of copying them. While the code includes checks against symbolic links in the source repository, which were added during the fix for CVE-2022-39253, these checks can still be raced because the hard link operation ultimately follows symlinks. If the object on the filesystem appears as a file during the check, and then a symlink during the operation, this will allow the adversary to bypass the check and create hardlinks in the destination objects directory to arbitrary, user-readable files. The problem has been patched in versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 22,
            "CWE Description": "The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",
            "Mapped CAPEC-ID": 126,
            "CAPEC Description": "An adversary uses path manipulation methods to exploit insufficient input validation of a target to obtain access to data that should be not be retrievable by ordinary well-formed requests. A typical variety of this attack involves specifying a path to a desired file together with dot-dot-slash characters, resulting in the file access API or function traversing out of the intended directory structure and into the root file system. By replacing or modifying the expected path information the access function or API retrieves the file desired by the attacker. These attacks either involve the attacker providing a complete path to a targeted file or using control characters (e.g. path separators (/ or ) and/or dots (.)) to reach desired directories or files.",
            "Original CWE-ID": "CWE-547",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2024-32002",
            "CVE-Description": "Git is a revision control system. Prior to versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4, repositories with submodules can be crafted in a way that exploits a bug in Git whereby it can be fooled into writing files not into the submodule's worktree but into a `.git/` directory. This allows writing a hook that will be executed while the clone operation is still running, giving the user no opportunity to inspect the code that is being executed. The problem has been patched in versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4. If symbolic link support is disabled in Git (e.g. via `git config --global core.symlinks false`), the described attack won't work. As always, it is best to avoid cloning repositories from untrusted sources.",
            "Severity": "CRITICAL",
            "Mapped CWE-ID": 15,
            "CWE Description": "One or more system settings or configuration elements can be externally controlled by a user.",
            "Mapped CAPEC-ID": 695,
            "CAPEC Description": "An adversary takes advantage of the redirect property of directly linked Version Control System (VCS) repositories to trick users into incorporating malicious code into their applications.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2024-32465",
            "CVE-Description": "Git is a revision control system. The Git project recommends to avoid working in untrusted repositories, and instead to clone it first with `git clone --no-local` to obtain a clean copy. Git has specific protections to make that a safe operation even with an untrusted source repository, but vulnerabilities allow those protections to be bypassed. In the context of cloning local repositories owned by other users, this vulnerability has been covered in CVE-2024-32004. But there are circumstances where the fixes for CVE-2024-32004 are not enough: For example, when obtaining a `.zip` file containing a full copy of a Git repository, it should not be trusted by default to be safe, as e.g. hooks could be configured to run within the context of that repository. The problem has been patched in versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4. As a workaround, avoid using Git in repositories that have been obtained via archives from untrusted sources.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 1123,
            "CWE Description": "The product uses too much self-modifying code.",
            "Mapped CAPEC-ID": 62,
            "CAPEC Description": "An attacker crafts malicious web links and distributes them (via web pages, email, etc.), typically in a targeted manner, hoping to induce users to click on the link and execute the malicious action against some third-party application. If successful, the action embedded in the malicious link will be processed and accepted by the targeted application with the users' privilege level. This type of attack leverages the persistence and implicit trust placed in user session cookies by many web applications today. In such an architecture, once the user authenticates to an application and a session cookie is created on the user's system, all following transactions for that session are authenticated using that cookie including potential actions initiated by an attacker and simply riding the existing session cookie.",
            "Original CWE-ID": "CWE-22",
            "Original CAPEC-ID": "126, 79, 76, 78, 64"
        },
        {
            "CVE-ID": "CVE-2023-25815",
            "CVE-Description": "In Git for Windows, the Windows port of Git, no localized messages are shipped with the installer. As a consequence, Git is expected not to localize messages at all, and skips the gettext initialization. However, due to a change in MINGW-packages, the `gettext()` function's implicit initialization no longer uses the runtime prefix but uses the hard-coded path `C:\\mingw64\\share\\locale` to look for localized messages. And since any authenticated user has the permission to create folders in `C:\\` (and since `C:\\mingw64` does not typically exist), it is possible for low-privilege users to place fake messages in that location where `git.exe` will pick them up in version 2.40.1.\n\nThis vulnerability is relatively hard to exploit and requires social engineering. For example, a legitimate message at the end of a clone could be maliciously modified to ask the user to direct their web browser to a malicious website, and the user might think that the message comes from Git and is legitimate. It does require local write access by the attacker, though, which makes this attack vector less likely. Version 2.40.1 contains a patch for this issue. Some workarounds are available. Do not work on a Windows machine with shared accounts, or alternatively create a `C:\\mingw64` folder and leave it empty. Users who have administrative rights may remove the permission to create folders in `C:\\`.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 145,
            "CAPEC Description": "An adversary spoofs a checksum message for the purpose of making a payload appear to have a valid corresponding checksum. Checksums are used to verify message integrity. They consist of some value based on the value of the message they are protecting. Hash codes are a common checksum mechanism. Both the sender and recipient are able to compute the checksum based on the contents of the message. If the message contents change between the sender and recipient, the sender and recipient will compute different checksum values. Since the sender's checksum value is transmitted with the message, the recipient would know that a modification occurred. In checksum spoofing an adversary modifies the message body and then modifies the corresponding checksum so that the recipient's checksum calculation will match the checksum (created by the adversary) in the message. This would prevent the recipient from realizing that a change occurred.",
            "Original CWE-ID": "CWE-134",
            "Original CAPEC-ID": "67, 135"
        },
        {
            "CVE-ID": "CVE-2024-32020",
            "CVE-Description": "Git is a revision control system. Prior to versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4, local clones may end up hardlinking files into the target repository's object database when source and target repository reside on the same disk. If the source repository is owned by a different user, then those hardlinked files may be rewritten at any point in time by the untrusted user. Cloning local repositories will cause Git to either copy or hardlink files of the source repository into the target repository. This significantly speeds up such local clones compared to doing a \"proper\" clone and saves both disk space and compute time. When cloning a repository located on the same disk that is owned by a different user than the current user we also end up creating such hardlinks. These files will continue to be owned and controlled by the potentially-untrusted user and can be rewritten by them at will in the future. The problem has been patched in versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 459,
            "CWE Description": "The product does not properly clean up and remove temporary or supporting resources after they have been used.",
            "Mapped CAPEC-ID": 27,
            "CAPEC Description": "This attack leverages the use of symbolic links (Symlinks) in order to write to sensitive files. An attacker can create a Symlink link to a target file not otherwise accessible to them. When the privileged program tries to create a temporary file with the same name as the Symlink link, it will actually write to the target file pointed to by the attackers' Symlink link. If the attacker can insert malicious content in the temporary file they will be writing to the sensitive file by using the Symlink. The race occurs because the system checks if the temporary file exists, then creates the file. The attacker would typically create the Symlink during the interval between the check and the creation of the temporary file.",
            "Original CWE-ID": "CWE-281",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2024-32021",
            "CVE-Description": "Git is a revision control system. Prior to versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4, when cloning a local source repository that contains symlinks via the filesystem, Git may create hardlinks to arbitrary user-readable files on the same filesystem as the target repository in the `objects/` directory. Cloning a local repository over the filesystem may creating hardlinks to arbitrary user-owned files on the same filesystem in the target Git repository's `objects/` directory. When cloning a repository over the filesystem (without explicitly specifying the `file://` protocol or `--no-local`), the optimizations for local cloning\nwill be used, which include attempting to hard link the object files instead of copying them. While the code includes checks against symbolic links in the source repository, which were added during the fix for CVE-2022-39253, these checks can still be raced because the hard link operation ultimately follows symlinks. If the object on the filesystem appears as a file during the check, and then a symlink during the operation, this will allow the adversary to bypass the check and create hardlinks in the destination objects directory to arbitrary, user-readable files. The problem has been patched in versions 2.45.1, 2.44.1, 2.43.4, 2.42.2, 2.41.1, 2.40.2, and 2.39.4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 22,
            "CWE Description": "The product uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the product does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.",
            "Mapped CAPEC-ID": 126,
            "CAPEC Description": "An adversary uses path manipulation methods to exploit insufficient input validation of a target to obtain access to data that should be not be retrievable by ordinary well-formed requests. A typical variety of this attack involves specifying a path to a desired file together with dot-dot-slash characters, resulting in the file access API or function traversing out of the intended directory structure and into the root file system. By replacing or modifying the expected path information the access function or API retrieves the file desired by the attacker. These attacks either involve the attacker providing a complete path to a targeted file or using control characters (e.g. path separators (/ or ) and/or dots (.)) to reach desired directories or files.",
            "Original CWE-ID": "CWE-547",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2011-3374",
            "CVE-Description": "It was found that apt-key in apt, all versions, do not correctly validate gpg keys with the master keyring, leading to a potential man-in-the-middle attack.",
            "Severity": "LOW",
            "Mapped CWE-ID": 295,
            "CWE Description": "The product does not validate, or incorrectly validates, a certificate.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-347",
            "Original CAPEC-ID": "475, 463"
        },
        {
            "CVE-ID": "CVE-2017-13716",
            "CVE-Description": "The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).",
            "Severity": "LOW",
            "Mapped CWE-ID": 1333,
            "CWE Description": "The product uses a regular expression with an inefficient, possibly exponential worst-case computational complexity that consumes excessive CPU cycles.",
            "Mapped CAPEC-ID": 26,
            "CAPEC Description": "The adversary targets a race condition occurring when multiple processes access and manipulate the same resource concurrently, and the outcome of the execution depends on the particular order in which the access takes place. The adversary can leverage a race condition by running the race, modifying the resource and modifying the normal execution flow. For instance, a race condition can occur while accessing a file: the adversary can trick the system by replacing the original file with their version and cause the system to read the malicious file.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2018-18483",
            "CVE-Description": "The get_count function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31, allows remote attackers to cause a denial of service (malloc called with the result of an integer-overflowing calculation) or possibly have unspecified other impact via a crafted string, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 191,
            "CWE Description": "The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.",
            "Mapped CAPEC-ID": 67,
            "CAPEC Description": "This attack targets applications and software that uses the syslog() function insecurely. If an application does not explicitely use a format string parameter in a call to syslog(), user input can be placed in the format string parameter leading to a format string injection attack. Adversaries can then inject malicious format string commands into the function call leading to a buffer overflow. There are many reported software vulnerabilities with the root cause being a misuse of the syslog() function.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20673",
            "CVE-Description": "The demangle_template function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31.1, contains an integer overflow vulnerability (for \"Create an array for saving the template argument values\") that can trigger a heap-based buffer overflow, as demonstrated by nm.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20712",
            "CVE-Description": "A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty, as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults, leading to denial-of-service, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2019-1010204",
            "CVE-Description": "GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation, Signed/Unsigned Comparison, Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497, elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2020-35448",
            "CVE-Description": "An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 67,
            "CAPEC Description": "This attack targets applications and software that uses the syslog() function insecurely. If an application does not explicitely use a format string parameter in a call to syslog(), user input can be placed in the format string parameter leading to a format string injection attack. Adversaries can then inject malicious format string commands into the function call leading to a buffer overflow. There are many reported software vulnerabilities with the root cause being a misuse of the syslog() function.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2021-20197",
            "CVE-Description": "There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar, objcopy, strip, ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users), an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.",
            "Severity": "LOW",
            "Mapped CWE-ID": 364,
            "CWE Description": "The product uses a signal handler that introduces a race condition.",
            "Mapped CAPEC-ID": 26,
            "CAPEC Description": "The adversary targets a race condition occurring when multiple processes access and manipulate the same resource concurrently, and the outcome of the execution depends on the particular order in which the access takes place. The adversary can leverage a race condition by running the race, modifying the resource and modifying the normal execution flow. For instance, a race condition can occur while accessing a file: the adversary can trick the system by replacing the original file with their version and cause the system to read the malicious file.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2021-32256",
            "CVE-Description": "An issue was discovered in GNU libiberty, as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-3549",
            "CVE-Description": "An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 126,
            "CAPEC Description": "An adversary uses path manipulation methods to exploit insufficient input validation of a target to obtain access to data that should be not be retrievable by ordinary well-formed requests. A typical variety of this attack involves specifying a path to a desired file together with dot-dot-slash characters, resulting in the file access API or function traversing out of the intended directory structure and into the root file system. By replacing or modifying the expected path information the access function or API retrieves the file desired by the attacker. These attacks either involve the attacker providing a complete path to a targeted file or using control characters (e.g. path separators (/ or ) and/or dots (.)) to reach desired directories or files.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-45078",
            "CVE-Description": "stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact, as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 44,
            "CAPEC Description": "An attack of this type exploits a buffer overflow vulnerability in the handling of binary resources. Binary resources may include music files like MP3, image files like JPEG files, and any other binary file. These attacks may pass unnoticed to the client machine through normal usage of files, such as a browser loading a seemingly innocent JPEG file. This can allow the adversary access to the execution stack and execute arbitrary code in the target process.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-46174",
            "CVE-Description": "Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35205",
            "CVE-Description": "An issue was discovered in Binutils readelf 2.38.50, reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 617,
            "CWE Description": "The product contains an assert() or similar statement that can be triggered by an attacker, which leads to an application exit or other behavior that is more severe than necessary.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-617",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35206",
            "CVE-Description": "Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-38533",
            "CVE-Description": "In GNU Binutils before 2.40, there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-4285",
            "CVE-Description": "An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-44840",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-45703",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-47673",
            "CVE-Description": "An issue was discovered in Binutils addr2line before 2.39.3, function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2022-48064",
            "CVE-Description": "GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2023-1579",
            "CVE-Description": "Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-1972",
            "CVE-Description": "A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25584",
            "CVE-Description": "An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2023-25585",
            "CVE-Description": "A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25586",
            "CVE-Description": "A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25588",
            "CVE-Description": "A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function, which may lead to an application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-0563",
            "CVE-Description": "A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 209,
            "CWE Description": "The product generates an error message that includes sensitive information about its environment, users, or associated data.",
            "Mapped CAPEC-ID": 87,
            "CAPEC Description": "An attacker employs forceful browsing (direct URL entry) to access portions of a website that are otherwise unreachable. Usually, a front controller or similar design pattern is employed to protect access to portions of a web application. Forceful browsing enables an attacker to access information, perform privileged operations and otherwise reach sections of the web application that have been improperly protected.",
            "Original CWE-ID": "CWE-209",
            "Original CAPEC-ID": "463, 215, 7, 54"
        },
        {
            "CVE-ID": "CVE-2024-33600",
            "CVE-Description": "nscd: Null pointer crashes after notfound response\n\nIf the Name Service Cache Daemon's (nscd) cache fails to add a not-found\nnetgroup response to the cache, the client request can result in a null\npointer dereference.  This flaw was introduced in glibc 2.15 when the\ncache was added to nscd.\n\nThis vulnerability is only present in the nscd binary.\n\n",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 166,
            "CAPEC Description": "An attacker forces the target into a previous state in order to leverage potential weaknesses in the target dependent upon a prior configuration or state-dependent factors. Even in cases where an attacker may not be able to directly control the configuration of the targeted application, they may be able to reset the configuration to a prior state since many applications implement reset functions.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2024-33601",
            "CVE-Description": "nscd: netgroup cache may terminate daemon on memory allocation failure\n\nThe Name Service Cache Daemon's (nscd) netgroup cache uses xmalloc or\nxrealloc and these functions may terminate the process due to a memory\nallocation failure resulting in a denial of service to the clients.  The\nflaw was introduced in glibc 2.15 when the cache was added to nscd.\n\nThis vulnerability is only present in the nscd binary.\n\n",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 770,
            "CWE Description": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
            "Mapped CAPEC-ID": 222,
            "CAPEC Description": "In an iFrame overlay attack the victim is tricked into unknowingly initiating some action in one system while interacting with the UI from seemingly completely different system.",
            "Original CWE-ID": "CWE-617",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2024-33602",
            "CVE-Description": "nscd: netgroup cache assumes NSS callback uses in-buffer strings\n\nThe Name Service Cache Daemon's (nscd) netgroup cache can corrupt memory\nwhen the NSS callback does not store all strings in the provided buffer.\nThe flaw was introduced in glibc 2.15 when the cache was added to nscd.\n\nThis vulnerability is only present in the nscd binary.\n\n",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 67,
            "CAPEC Description": "This attack targets applications and software that uses the syslog() function insecurely. If an application does not explicitely use a format string parameter in a call to syslog(), user input can be placed in the format string parameter leading to a format string injection attack. Adversaries can then inject malicious format string commands into the function call leading to a buffer overflow. There are many reported software vulnerabilities with the root cause being a misuse of the syslog() function.",
            "Original CWE-ID": "CWE-466",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-1304",
            "CVE-Description": "An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 77,
            "CAPEC Description": "This attack targets user controlled variables (DEBUG=1, PHP Globals, and So Forth). An adversary can override variables leveraging user-supplied, untrusted query variables directly used on the application server without any data sanitization. In extreme cases, the adversary can change variables controlling the business logic of the application. For instance, in languages like PHP, a number of poorly set default configurations may allow the user to override variables.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2017-13716",
            "CVE-Description": "The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).",
            "Severity": "LOW",
            "Mapped CWE-ID": 1333,
            "CWE Description": "The product uses a regular expression with an inefficient, possibly exponential worst-case computational complexity that consumes excessive CPU cycles.",
            "Mapped CAPEC-ID": 26,
            "CAPEC Description": "The adversary targets a race condition occurring when multiple processes access and manipulate the same resource concurrently, and the outcome of the execution depends on the particular order in which the access takes place. The adversary can leverage a race condition by running the race, modifying the resource and modifying the normal execution flow. For instance, a race condition can occur while accessing a file: the adversary can trick the system by replacing the original file with their version and cause the system to read the malicious file.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2018-18483",
            "CVE-Description": "The get_count function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31, allows remote attackers to cause a denial of service (malloc called with the result of an integer-overflowing calculation) or possibly have unspecified other impact via a crafted string, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 191,
            "CWE Description": "The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.",
            "Mapped CAPEC-ID": 67,
            "CAPEC Description": "This attack targets applications and software that uses the syslog() function insecurely. If an application does not explicitely use a format string parameter in a call to syslog(), user input can be placed in the format string parameter leading to a format string injection attack. Adversaries can then inject malicious format string commands into the function call leading to a buffer overflow. There are many reported software vulnerabilities with the root cause being a misuse of the syslog() function.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20673",
            "CVE-Description": "The demangle_template function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31.1, contains an integer overflow vulnerability (for \"Create an array for saving the template argument values\") that can trigger a heap-based buffer overflow, as demonstrated by nm.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20712",
            "CVE-Description": "A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty, as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults, leading to denial-of-service, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2019-1010204",
            "CVE-Description": "GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation, Signed/Unsigned Comparison, Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497, elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2020-35448",
            "CVE-Description": "An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 67,
            "CAPEC Description": "This attack targets applications and software that uses the syslog() function insecurely. If an application does not explicitely use a format string parameter in a call to syslog(), user input can be placed in the format string parameter leading to a format string injection attack. Adversaries can then inject malicious format string commands into the function call leading to a buffer overflow. There are many reported software vulnerabilities with the root cause being a misuse of the syslog() function.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2021-20197",
            "CVE-Description": "There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar, objcopy, strip, ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users), an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.",
            "Severity": "LOW",
            "Mapped CWE-ID": 364,
            "CWE Description": "The product uses a signal handler that introduces a race condition.",
            "Mapped CAPEC-ID": 26,
            "CAPEC Description": "The adversary targets a race condition occurring when multiple processes access and manipulate the same resource concurrently, and the outcome of the execution depends on the particular order in which the access takes place. The adversary can leverage a race condition by running the race, modifying the resource and modifying the normal execution flow. For instance, a race condition can occur while accessing a file: the adversary can trick the system by replacing the original file with their version and cause the system to read the malicious file.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2021-32256",
            "CVE-Description": "An issue was discovered in GNU libiberty, as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-3549",
            "CVE-Description": "An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 126,
            "CAPEC Description": "An adversary uses path manipulation methods to exploit insufficient input validation of a target to obtain access to data that should be not be retrievable by ordinary well-formed requests. A typical variety of this attack involves specifying a path to a desired file together with dot-dot-slash characters, resulting in the file access API or function traversing out of the intended directory structure and into the root file system. By replacing or modifying the expected path information the access function or API retrieves the file desired by the attacker. These attacks either involve the attacker providing a complete path to a targeted file or using control characters (e.g. path separators (/ or ) and/or dots (.)) to reach desired directories or files.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-45078",
            "CVE-Description": "stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact, as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 44,
            "CAPEC Description": "An attack of this type exploits a buffer overflow vulnerability in the handling of binary resources. Binary resources may include music files like MP3, image files like JPEG files, and any other binary file. These attacks may pass unnoticed to the client machine through normal usage of files, such as a browser loading a seemingly innocent JPEG file. This can allow the adversary access to the execution stack and execute arbitrary code in the target process.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-46174",
            "CVE-Description": "Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35205",
            "CVE-Description": "An issue was discovered in Binutils readelf 2.38.50, reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 617,
            "CWE Description": "The product contains an assert() or similar statement that can be triggered by an attacker, which leads to an application exit or other behavior that is more severe than necessary.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-617",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35206",
            "CVE-Description": "Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-38533",
            "CVE-Description": "In GNU Binutils before 2.40, there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-4285",
            "CVE-Description": "An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-44840",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-45703",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-47673",
            "CVE-Description": "An issue was discovered in Binutils addr2line before 2.39.3, function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2022-48064",
            "CVE-Description": "GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2023-1579",
            "CVE-Description": "Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-1972",
            "CVE-Description": "A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25584",
            "CVE-Description": "An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2023-25585",
            "CVE-Description": "A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25586",
            "CVE-Description": "A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25588",
            "CVE-Description": "A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function, which may lead to an application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2017-13716",
            "CVE-Description": "The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).",
            "Severity": "LOW",
            "Mapped CWE-ID": 1333,
            "CWE Description": "The product uses a regular expression with an inefficient, possibly exponential worst-case computational complexity that consumes excessive CPU cycles.",
            "Mapped CAPEC-ID": 26,
            "CAPEC Description": "The adversary targets a race condition occurring when multiple processes access and manipulate the same resource concurrently, and the outcome of the execution depends on the particular order in which the access takes place. The adversary can leverage a race condition by running the race, modifying the resource and modifying the normal execution flow. For instance, a race condition can occur while accessing a file: the adversary can trick the system by replacing the original file with their version and cause the system to read the malicious file.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2018-18483",
            "CVE-Description": "The get_count function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31, allows remote attackers to cause a denial of service (malloc called with the result of an integer-overflowing calculation) or possibly have unspecified other impact via a crafted string, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 191,
            "CWE Description": "The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.",
            "Mapped CAPEC-ID": 67,
            "CAPEC Description": "This attack targets applications and software that uses the syslog() function insecurely. If an application does not explicitely use a format string parameter in a call to syslog(), user input can be placed in the format string parameter leading to a format string injection attack. Adversaries can then inject malicious format string commands into the function call leading to a buffer overflow. There are many reported software vulnerabilities with the root cause being a misuse of the syslog() function.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20673",
            "CVE-Description": "The demangle_template function in cplus-dem.c in GNU libiberty, as distributed in GNU Binutils 2.31.1, contains an integer overflow vulnerability (for \"Create an array for saving the template argument values\") that can trigger a heap-based buffer overflow, as demonstrated by nm.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-20712",
            "CVE-Description": "A heap-based buffer over-read exists in the function d_expression_1 in cp-demangle.c in GNU libiberty, as distributed in GNU Binutils 2.31.1. A crafted input can cause segmentation faults, leading to denial-of-service, as demonstrated by c++filt.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2019-1010204",
            "CVE-Description": "GNU binutils gold gold v1.11-v1.16 (GNU binutils v2.21-v2.31.1) is affected by: Improper Input Validation, Signed/Unsigned Comparison, Out-of-bounds Read. The impact is: Denial of service. The component is: gold/fileread.cc:497, elfcpp/elfcpp_file.h:644. The attack vector is: An ELF file with an invalid e_shoff header field must be opened.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2020-35448",
            "CVE-Description": "An issue was discovered in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.35.1. A heap-based buffer over-read can occur in bfd_getl_signed_32 in libbfd.c because sh_entsize is not validated in _bfd_elf_slurp_secondary_reloc_section in elf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 67,
            "CAPEC Description": "This attack targets applications and software that uses the syslog() function insecurely. If an application does not explicitely use a format string parameter in a call to syslog(), user input can be placed in the format string parameter leading to a format string injection attack. Adversaries can then inject malicious format string commands into the function call leading to a buffer overflow. There are many reported software vulnerabilities with the root cause being a misuse of the syslog() function.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2021-20197",
            "CVE-Description": "There is an open race window when writing output in the following utilities in GNU binutils version 2.35 and earlier:ar, objcopy, strip, ranlib. When these utilities are run as a privileged user (presumably as part of a script updating binaries across different users), an unprivileged user can trick these utilities into getting ownership of arbitrary files through a symlink.",
            "Severity": "LOW",
            "Mapped CWE-ID": 364,
            "CWE Description": "The product uses a signal handler that introduces a race condition.",
            "Mapped CAPEC-ID": 26,
            "CAPEC Description": "The adversary targets a race condition occurring when multiple processes access and manipulate the same resource concurrently, and the outcome of the execution depends on the particular order in which the access takes place. The adversary can leverage a race condition by running the race, modifying the resource and modifying the normal execution flow. For instance, a race condition can occur while accessing a file: the adversary can trick the system by replacing the original file with their version and cause the system to read the malicious file.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2021-32256",
            "CVE-Description": "An issue was discovered in GNU libiberty, as distributed in GNU Binutils 2.36. It is a stack-overflow issue in demangle_type in rust-demangle.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-3549",
            "CVE-Description": "An out of bounds flaw was found in GNU binutils objdump utility version 2.36. An attacker could use this flaw and pass a large section to avr_elf32_load_records_from_section() probably resulting in a crash or in some cases memory corruption. The highest threat from this vulnerability is to integrity as well as system availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 126,
            "CAPEC Description": "An adversary uses path manipulation methods to exploit insufficient input validation of a target to obtain access to data that should be not be retrievable by ordinary well-formed requests. A typical variety of this attack involves specifying a path to a desired file together with dot-dot-slash characters, resulting in the file access API or function traversing out of the intended directory structure and into the root file system. By replacing or modifying the expected path information the access function or API retrieves the file desired by the attacker. These attacks either involve the attacker providing a complete path to a targeted file or using control characters (e.g. path separators (/ or ) and/or dots (.)) to reach desired directories or files.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-45078",
            "CVE-Description": "stab_xcoff_builtin_type in stabs.c in GNU Binutils through 2.37 allows attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact, as demonstrated by an out-of-bounds write. NOTE: this issue exists because of an incorrect fix for CVE-2018-12699.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 44,
            "CAPEC Description": "An attack of this type exploits a buffer overflow vulnerability in the handling of binary resources. Binary resources may include music files like MP3, image files like JPEG files, and any other binary file. These attacks may pass unnoticed to the client machine through normal usage of files, such as a browser loading a seemingly innocent JPEG file. This can allow the adversary access to the execution stack and execute arbitrary code in the target process.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-46174",
            "CVE-Description": "Heap-based Buffer Overflow in function bfd_getl32 in Binutils objdump 3.37.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35205",
            "CVE-Description": "An issue was discovered in Binutils readelf 2.38.50, reachable assertion failure in function display_debug_names allows attackers to cause a denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 617,
            "CWE Description": "The product contains an assert() or similar statement that can be triggered by an attacker, which leads to an application exit or other behavior that is more severe than necessary.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-617",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-35206",
            "CVE-Description": "Null pointer dereference vulnerability in Binutils readelf 2.38.50 via function read_and_display_attr_value in file dwarf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-38533",
            "CVE-Description": "In GNU Binutils before 2.40, there is a heap-buffer-overflow in the error function bfd_getl32 when called from the strip_main function in strip-new via a crafted file.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-4285",
            "CVE-Description": "An illegal memory access flaw was found in the binutils package. Parsing an ELF file containing corrupt symbol version information may result in a denial of service. This issue is the result of an incomplete fix for CVE-2020-16599.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-44840",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function find_section_in_set in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-45703",
            "CVE-Description": "Heap buffer overflow vulnerability in binutils readelf before 2.40 via function display_debug_section in file readelf.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-47673",
            "CVE-Description": "An issue was discovered in Binutils addr2line before 2.39.3, function parse_module contains multiple out of bound reads which may cause a denial of service or other unspecified impacts.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2022-48064",
            "CVE-Description": "GNU Binutils before 2.40 was discovered to contain an excessive memory consumption vulnerability via the function bfd_dwarf2_find_nearest_line_with_alt at dwarf2.c. The attacker could supply a crafted ELF file and cause a DNS attack.",
            "Severity": "LOW",
            "Mapped CWE-ID": 190,
            "CWE Description": "The product performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2023-1579",
            "CVE-Description": "Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-1972",
            "CVE-Description": "A potential heap based buffer overflow was found in _bfd_elf_slurp_version_tables() in bfd/elf.c. This may lead to loss of availability.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25584",
            "CVE-Description": "An out-of-bounds read flaw was found in the parse_module function in bfd/vms-alpha.c in Binutils.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2023-25585",
            "CVE-Description": "A flaw was found in Binutils. The use of an uninitialized field in the struct module *module may lead to application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25586",
            "CVE-Description": "A flaw was found in Binutils. A logic fail in the bfd_init_section_decompress_status function may lead to the use of an uninitialized variable that can cause a crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25588",
            "CVE-Description": "A flaw was found in Binutils. The field `the_bfd` of `asymbol`struct is uninitialized in the `bfd_mach_o_get_synthetic_symtab` function, which may lead to an application crash and local denial of service.",
            "Severity": "LOW",
            "Mapped CWE-ID": 908,
            "CWE Description": "The product uses or accesses a resource that has not been initialized.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-908",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-23914",
            "CVE-Description": "A cleartext transmission of sensitive information vulnerability exists in curl <v7.88.0 that could cause HSTS functionality fail when multiple URLs are requested serially. Using its HSTS support, curl can be instructed to use HTTPS instead of usingan insecure clear-text HTTP step even when HTTP is provided in the URL. ThisHSTS mechanism would however surprisingly be ignored by subsequent transferswhen done on the same command line because the state would not be properlycarried on.",
            "Severity": "CRITICAL",
            "Mapped CWE-ID": 312,
            "CWE Description": "The product stores sensitive information in cleartext within a resource that might be accessible to another control sphere.",
            "Mapped CAPEC-ID": 67,
            "CAPEC Description": "This attack targets applications and software that uses the syslog() function insecurely. If an application does not explicitely use a format string parameter in a call to syslog(), user input can be placed in the format string parameter leading to a format string injection attack. Adversaries can then inject malicious format string commands into the function call leading to a buffer overflow. There are many reported software vulnerabilities with the root cause being a misuse of the syslog() function.",
            "Original CWE-ID": "CWE-319",
            "Original CAPEC-ID": "102, 117, 383, 477, 65"
        },
        {
            "CVE-ID": "CVE-2022-42916",
            "CVE-Description": "In curl before 7.86.0, the HSTS check could be bypassed to trick it into staying with HTTP. Using its HSTS support, curl can be instructed to use HTTPS directly (instead of using an insecure cleartext HTTP step) even when HTTP is provided in the URL. This mechanism could be bypassed if the host name in the given URL uses IDN characters that get replaced with ASCII counterparts as part of the IDN conversion, e.g., using the character UTF-8 U+3002 (IDEOGRAPHIC FULL STOP) instead of the common ASCII full stop of U+002E (.). The earliest affected version is 7.77.0 2021-05-26.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 444,
            "CWE Description": "The product acts as an intermediary HTTP agent (such as a proxy or firewall) in the data flow between two entities such as a client and server, but it does not interpret malformed HTTP requests or responses in ways that are consistent with how the messages will be processed by those entities that are at the ultimate destination.",
            "Mapped CAPEC-ID": 488,
            "CAPEC Description": "An adversary may execute a flooding attack using the HTTP protocol with the intent to deny legitimate users access to a service by consuming resources at the application layer such as web services and their infrastructure. These attacks use legitimate session-based HTTP GET requests designed to consume large amounts of a server's resources. Since these are legitimate sessions this attack is very difficult to detect.",
            "Original CWE-ID": "CWE-319",
            "Original CAPEC-ID": "102, 117, 383, 477, 65"
        },
        {
            "CVE-ID": "CVE-2022-43551",
            "CVE-Description": "A vulnerability exists in curl <7.87.0 HSTS check that could be bypassed to trick it to keep using HTTP. Using its HSTS support, curl can be instructed to use HTTPS instead of using an insecure clear-text HTTP step even when HTTP is provided in the URL. However, the HSTS mechanism could be bypassed if the host name in the given URL first uses IDN characters that get replaced to ASCII counterparts as part of the IDN conversion. Like using the character UTF-8 U+3002 (IDEOGRAPHIC FULL STOP) instead of the common ASCII full stop (U+002E) `.`. Then in a subsequent request, it does not detect the HSTS state and makes a clear text transfer. Because it would store the info IDN encoded but look for it IDN decoded.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 459,
            "CWE Description": "The product does not properly clean up and remove temporary or supporting resources after they have been used.",
            "Mapped CAPEC-ID": 487,
            "CAPEC Description": "An adversary may execute a flooding attack using the ICMP protocol with the intent to deny legitimate users access to a service by consuming the available network bandwidth. A typical attack involves a victim server receiving ICMP packets at a high rate from a wide range of source addresses. Additionally, due to the session-less nature of the ICMP protocol, the source of a packet is easily spoofed making it difficult to find the source of the attack.",
            "Original CWE-ID": "CWE-319",
            "Original CAPEC-ID": "102, 117, 383, 477, 65"
        },
        {
            "CVE-ID": "CVE-2013-0340",
            "CVE-Description": "expat 2.1.0 and earlier does not properly handle entities expansion unless an application developer uses the XML_SetEntityDeclHandler function, which allows remote attackers to cause a denial of service (resource consumption), send HTTP requests to intranet servers, or read arbitrary files via a crafted XML document, aka an XML External Entity (XXE) issue.  NOTE: it could be argued that because expat already provides the ability to disable external entity expansion, the responsibility for resolving this issue lies with application developers; according to this argument, this entry should be REJECTed, and each affected application would need its own CVE.",
            "Severity": "LOW",
            "Mapped CWE-ID": 15,
            "CWE Description": "One or more system settings or configuration elements can be externally controlled by a user.",
            "Mapped CAPEC-ID": 528,
            "CAPEC Description": "An adversary may execute a flooding attack using XML messages with the intent to deny legitimate users access to a web service. These attacks are accomplished by sending a large number of XML based requests and letting the service attempt to parse each one. In many cases this type of an attack will result in a XML Denial of Service (XDoS) due to an application becoming unstable, freezing, or crashing.",
            "Original CWE-ID": "CWE-611",
            "Original CAPEC-ID": "221"
        },
        {
            "CVE-ID": "CVE-2023-52426",
            "CVE-Description": "libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.",
            "Severity": "LOW",
            "Mapped CWE-ID": 112,
            "CWE Description": "The product accepts XML from an untrusted source but does not validate the XML against the proper schema.",
            "Mapped CAPEC-ID": 221,
            "CAPEC Description": "This attack takes advantage of the entity replacement property of certain data serialization languages (e.g., XML, YAML, etc.) where the value of the replacement is a URI. A well-crafted file could have the entity refer to a URI that consumes a large amount of resources to create a denial of service condition. This can cause the system to either freeze, crash, or execute arbitrary code depending on the URI.",
            "Original CWE-ID": "CWE-776",
            "Original CAPEC-ID": "197"
        },
        {
            "CVE-ID": "CVE-2022-1304",
            "CVE-Description": "An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 77,
            "CAPEC Description": "This attack targets user controlled variables (DEBUG=1, PHP Globals, and So Forth). An adversary can override variables leveraging user-supplied, untrusted query variables directly used on the application server without any data sanitization. In extreme cases, the adversary can change variables controlling the business logic of the application. For instance, in languages like PHP, a number of poorly set default configurations may allow the user to override variables.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2022-31782",
            "CVE-Description": "ftbench.c in FreeType Demo Programs through 2.12.1 has a heap-based buffer overflow.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 263,
            "CAPEC Description": "This describes an attack where an application is forced to use a file that an attacker has corrupted. The result is often a denial of service caused by the application being unable to process the corrupted file, but other results, including the disabling of filters or access controls (if the application fails in an unsafe way rather than failing by locking down) or buffer overflows are possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-38115",
            "CVE-Description": "read_header_tga in gd_tga.c in the GD Graphics Library (aka LibGD) through 2.3.2 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted TGA file.",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2021-40812",
            "CVE-Description": "The GD Graphics Library (aka LibGD) through 2.3.2 has an out-of-bounds read because of the lack of certain gdGetBuf and gdPutBuf return value checks.",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2024-28835",
            "CVE-Description": "A flaw has been discovered in GnuTLS where an application crash can be induced when attempting to verify a specially crafted .pem bundle using the \"certtool --verify-chain\" command.",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-248",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2018-5709",
            "CVE-Description": "An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable \"dbentry->n_key_data\" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a \"u4\" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.",
            "Severity": "LOW",
            "Mapped CWE-ID": 79,
            "CWE Description": "The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.",
            "Mapped CAPEC-ID": 87,
            "CAPEC Description": "An attacker employs forceful browsing (direct URL entry) to access portions of a website that are otherwise unreachable. Usually, a front controller or similar design pattern is employed to protect access to portions of a web application. Forceful browsing enables an attacker to access information, perform privileged operations and otherwise reach sections of the web application that have been improperly protected.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-5709",
            "CVE-Description": "An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable \"dbentry->n_key_data\" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a \"u4\" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.",
            "Severity": "LOW",
            "Mapped CWE-ID": 79,
            "CWE Description": "The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.",
            "Mapped CAPEC-ID": 87,
            "CAPEC Description": "An attacker employs forceful browsing (direct URL entry) to access portions of a website that are otherwise unreachable. Usually, a front controller or similar design pattern is employed to protect access to portions of a web application. Forceful browsing enables an attacker to access information, perform privileged operations and otherwise reach sections of the web application that have been improperly protected.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-5709",
            "CVE-Description": "An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable \"dbentry->n_key_data\" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a \"u4\" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.",
            "Severity": "LOW",
            "Mapped CWE-ID": 79,
            "CWE Description": "The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.",
            "Mapped CAPEC-ID": 87,
            "CAPEC Description": "An attacker employs forceful browsing (direct URL entry) to access portions of a website that are otherwise unreachable. Usually, a front controller or similar design pattern is employed to protect access to portions of a web application. Forceful browsing enables an attacker to access information, perform privileged operations and otherwise reach sections of the web application that have been improperly protected.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2018-5709",
            "CVE-Description": "An issue was discovered in MIT Kerberos 5 (aka krb5) through 1.16. There is a variable \"dbentry->n_key_data\" in kadmin/dbutil/dump.c that can store 16-bit data but unknowingly the developer has assigned a \"u4\" variable to it, which is for 32-bit data. An attacker can use this vulnerability to affect other artifacts of the database as we know that a Kerberos database dump file contains trusted data.",
            "Severity": "LOW",
            "Mapped CWE-ID": 79,
            "CWE Description": "The product does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.",
            "Mapped CAPEC-ID": 87,
            "CAPEC Description": "An attacker employs forceful browsing (direct URL entry) to access portions of a website that are otherwise unreachable. Usually, a front controller or similar design pattern is employed to protect access to portions of a web application. Forceful browsing enables an attacker to access information, perform privileged operations and otherwise reach sections of the web application that have been improperly protected.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2023-2953",
            "CVE-Description": "A vulnerability was found in openldap. This security flaw causes a null pointer dereference in ber_memalloc_x() function.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 395,
            "CWE Description": "Catching NullPointerException should not be used as an alternative to programmatic checks to prevent dereferencing a null pointer.",
            "Mapped CAPEC-ID": 486,
            "CAPEC Description": "An adversary may execute a flooding attack using the UDP protocol with the intent to deny legitimate users access to a service by consuming the available network bandwidth. Additionally, firewalls often open a port for each UDP connection destined for a service with an open UDP port, meaning the firewalls in essence save the connection state thus the high packet nature of a UDP flood can also overwhelm resources allocated to the firewall. UDP attacks can also target services like DNS or VoIP which utilize these protocols. Additionally, due to the session-less nature of the UDP protocol, the source of a packet is easily spoofed making it difficult to find the source of the attack.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2020-15719",
            "CVE-Description": "libldap in certain third-party OpenLDAP packages has a certificate-validation flaw when the third-party package is asserting RFC6125 support. It considers CN even when there is a non-matching subjectAltName (SAN). This is fixed in, for example, openldap-2.4.46-10.el8 in Red Hat Enterprise Linux.",
            "Severity": "LOW",
            "Mapped CWE-ID": 295,
            "CWE Description": "The product does not validate, or incorrectly validates, a certificate.",
            "Mapped CAPEC-ID": 475,
            "CAPEC Description": "An adversary exploits a cryptographic weakness in the signature verification algorithm implementation to generate a valid signature without knowing the key.",
            "Original CWE-ID": "CWE-295",
            "Original CAPEC-ID": "475, 459"
        },
        {
            "CVE-ID": "CVE-2022-0563",
            "CVE-Description": "A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 209,
            "CWE Description": "The product generates an error message that includes sensitive information about its environment, users, or associated data.",
            "Mapped CAPEC-ID": 87,
            "CAPEC Description": "An attacker employs forceful browsing (direct URL entry) to access portions of a website that are otherwise unreachable. Usually, a front controller or similar design pattern is employed to protect access to portions of a web application. Forceful browsing enables an attacker to access information, perform privileged operations and otherwise reach sections of the web application that have been improperly protected.",
            "Original CWE-ID": "CWE-209",
            "Original CAPEC-ID": "463, 215, 7, 54"
        },
        {
            "CVE-ID": "CVE-2019-20838",
            "CVE-Description": "libpcre in PCRE before 8.43 allows a subject buffer over-read in JIT when UTF is disabled, and \\X or \\R has more than one fixed quantifier, a related issue to CVE-2019-20454.",
            "Severity": "LOW",
            "Mapped CWE-ID": 805,
            "CWE Description": "The product uses a sequential operation to read or write a buffer, but it uses an incorrect length value that causes it to access memory that is outside of the bounds of the buffer.",
            "Mapped CAPEC-ID": 100,
            "CAPEC Description": "Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an adversary. As a consequence, an adversary is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the adversaries' choice.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2020-16156",
            "CVE-Description": "CPAN 2.28 allows Signature Verification Bypass.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 303,
            "CWE Description": "The requirements for the product dictate the use of an established authentication algorithm, but the implementation of the algorithm is incorrect.",
            "Mapped CAPEC-ID": 528,
            "CAPEC Description": "An adversary may execute a flooding attack using XML messages with the intent to deny legitimate users access to a web service. These attacks are accomplished by sending a large number of XML based requests and letting the service attempt to parse each one. In many cases this type of an attack will result in a XML Denial of Service (XDoS) due to an application becoming unstable, freezing, or crashing.",
            "Original CWE-ID": "CWE-347",
            "Original CAPEC-ID": "475, 463"
        },
        {
            "CVE-ID": "CVE-2023-31484",
            "CVE-Description": "CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 295,
            "CWE Description": "The product does not validate, or incorrectly validates, a certificate.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-295",
            "Original CAPEC-ID": "475, 459"
        },
        {
            "CVE-ID": "CVE-2023-47038",
            "CVE-Description": "A vulnerability was found in perl 5.30.0 through 5.38.0. This issue occurs when a crafted regular expression is compiled by perl, which can allow an attacker controlled byte buffer overflow in a heap allocated buffer.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2011-4116",
            "CVE-Description": "_is_safe in the File::Temp module for Perl does not properly handle symlinks.",
            "Severity": "LOW",
            "Mapped CWE-ID": 1333,
            "CWE Description": "The product uses a regular expression with an inefficient, possibly exponential worst-case computational complexity that consumes excessive CPU cycles.",
            "Mapped CAPEC-ID": 528,
            "CAPEC Description": "An adversary may execute a flooding attack using XML messages with the intent to deny legitimate users access to a web service. These attacks are accomplished by sending a large number of XML based requests and letting the service attempt to parse each one. In many cases this type of an attack will result in a XML Denial of Service (XDoS) due to an application becoming unstable, freezing, or crashing.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2023-31486",
            "CVE-Description": "HTTP::Tiny before 0.083, a Perl core module since 5.13.9 and available standalone on CPAN, has an insecure default TLS configuration where users must opt in to verify certificates.",
            "Severity": "LOW",
            "Mapped CWE-ID": 1392,
            "CWE Description": "The product uses default credentials (such as passwords or cryptographic keys) for potentially critical functionality.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-295",
            "Original CAPEC-ID": "475, 459"
        },
        {
            "CVE-ID": "CVE-2023-4016",
            "CVE-Description": "Under some circumstances, this weakness allows a user who has access to run the \u201cps\u201d utility on a machine, the ability to write almost unlimited amounts of unfiltered data into the process heap.",
            "Severity": "LOW",
            "Mapped CWE-ID": 306,
            "CWE Description": "The product does not perform any authentication for functionality that requires a provable user identity or consumes a significant amount of resources.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-28861",
            "CVE-Description": "Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states \"Warning: http.server is not recommended for production. It only implements basic security checks.\"",
            "Severity": "LOW",
            "Mapped CWE-ID": 601,
            "CWE Description": "A web application accepts a user-controlled input that specifies a link to an external site, and uses that link in a Redirect. This simplifies phishing attacks.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-601",
            "Original CAPEC-ID": "178"
        },
        {
            "CVE-ID": "CVE-2022-37454",
            "CVE-Description": "The Keccak XKCP SHA-3 reference implementation before fdc6fef has an integer overflow and resultant buffer overflow that allows attackers to execute arbitrary code or eliminate expected cryptographic properties. This occurs in the sponge function interface.",
            "Severity": "LOW",
            "Mapped CWE-ID": 191,
            "CWE Description": "The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2021-28861",
            "CVE-Description": "Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states \"Warning: http.server is not recommended for production. It only implements basic security checks.\"",
            "Severity": "LOW",
            "Mapped CWE-ID": 601,
            "CWE Description": "A web application accepts a user-controlled input that specifies a link to an external site, and uses that link in a Redirect. This simplifies phishing attacks.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-601",
            "Original CAPEC-ID": "178"
        },
        {
            "CVE-ID": "CVE-2022-37454",
            "CVE-Description": "The Keccak XKCP SHA-3 reference implementation before fdc6fef has an integer overflow and resultant buffer overflow that allows attackers to execute arbitrary code or eliminate expected cryptographic properties. This occurs in the sponge function interface.",
            "Severity": "LOW",
            "Mapped CWE-ID": 191,
            "CWE Description": "The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2021-36087",
            "CVE-Description": "The CIL compiler in SELinux 3.2 has a heap-based buffer over-read in ebitmap_match_any (called indirectly from cil_check_neverallow). This occurs because there is sometimes a lack of checks for invalid statements in an optional block.",
            "Severity": "LOW",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 44,
            "CAPEC Description": "An attack of this type exploits a buffer overflow vulnerability in the handling of binary resources. Binary resources may include music files like MP3, image files like JPEG files, and any other binary file. These attacks may pass unnoticed to the client machine through normal usage of files, such as a browser loading a seemingly innocent JPEG file. This can allow the adversary access to the execution stack and execute arbitrary code in the target process.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2022-0563",
            "CVE-Description": "A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 209,
            "CWE Description": "The product generates an error message that includes sensitive information about its environment, users, or associated data.",
            "Mapped CAPEC-ID": 87,
            "CAPEC Description": "An attacker employs forceful browsing (direct URL entry) to access portions of a website that are otherwise unreachable. Usually, a front controller or similar design pattern is employed to protect access to portions of a web application. Forceful browsing enables an attacker to access information, perform privileged operations and otherwise reach sections of the web application that have been improperly protected.",
            "Original CWE-ID": "CWE-209",
            "Original CAPEC-ID": "463, 215, 7, 54"
        },
        {
            "CVE-ID": "CVE-2022-1304",
            "CVE-Description": "An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 77,
            "CAPEC Description": "This attack targets user controlled variables (DEBUG=1, PHP Globals, and So Forth). An adversary can override variables leveraging user-supplied, untrusted query variables directly used on the application server without any data sanitization. In extreme cases, the adversary can change variables controlling the business logic of the application. For instance, in languages like PHP, a number of poorly set default configurations may allow the user to override variables.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2020-22218",
            "CVE-Description": "An issue was discovered in function _libssh2_packet_add in libssh2 1.10.0 allows attackers to access out of bounds memory.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2013-4392",
            "CVE-Description": "systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.",
            "Severity": "LOW",
            "Mapped CWE-ID": 276,
            "CWE Description": "During installation, installed file permissions are set to allow anyone to modify those files.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2020-13529",
            "CVE-Description": "An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.",
            "Severity": "LOW",
            "Mapped CWE-ID": 290,
            "CWE Description": "This attack-focused weakness is caused by incorrectly implemented authentication schemes that are subject to spoofing attacks.",
            "Mapped CAPEC-ID": 126,
            "CAPEC Description": "An adversary uses path manipulation methods to exploit insufficient input validation of a target to obtain access to data that should be not be retrievable by ordinary well-formed requests. A typical variety of this attack involves specifying a path to a desired file together with dot-dot-slash characters, resulting in the file access API or function traversing out of the intended directory structure and into the root file system. By replacing or modifying the expected path information the access function or API retrieves the file desired by the attacker. These attacks either involve the attacker providing a complete path to a targeted file or using control characters (e.g. path separators (/ or ) and/or dots (.)) to reach desired directories or files.",
            "Original CWE-ID": "CWE-290",
            "Original CAPEC-ID": "459, 667, 60, 59, 476, 473, 94, 21, 22, 461"
        },
        {
            "CVE-ID": "CVE-2023-31437",
            "CVE-Description": "An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
            "Severity": "LOW",
            "Mapped CWE-ID": 1123,
            "CWE Description": "The product uses too much self-modifying code.",
            "Mapped CAPEC-ID": 486,
            "CAPEC Description": "An adversary may execute a flooding attack using the UDP protocol with the intent to deny legitimate users access to a service by consuming the available network bandwidth. Additionally, firewalls often open a port for each UDP connection destined for a service with an open UDP port, meaning the firewalls in essence save the connection state thus the high packet nature of a UDP flood can also overwhelm resources allocated to the firewall. UDP attacks can also target services like DNS or VoIP which utilize these protocols. Additionally, due to the session-less nature of the UDP protocol, the source of a packet is easily spoofed making it difficult to find the source of the attack.",
            "Original CWE-ID": "CWE-354",
            "Original CAPEC-ID": "145, 463, 75"
        },
        {
            "CVE-ID": "CVE-2023-31438",
            "CVE-Description": "An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
            "Severity": "LOW",
            "Mapped CWE-ID": 649,
            "CWE Description": "The product uses obfuscation or encryption of inputs that should not be mutable by an external actor, but the product does not use integrity checks to detect if those inputs have been modified.",
            "Mapped CAPEC-ID": 331,
            "CAPEC Description": "An adversary sends a UDP packet to a closed port on the target machine to solicit an IP Header's total length field value within the echoed 'Port Unreachable error message. This type of behavior is useful for building a signature-base of operating system responses, particularly when error messages contain other types of information that is useful identifying specific operating system responses.",
            "Original CWE-ID": "CWE-354",
            "Original CAPEC-ID": "145, 463, 75"
        },
        {
            "CVE-ID": "CVE-2023-31439",
            "CVE-Description": "An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
            "Severity": "LOW",
            "Mapped CWE-ID": 1123,
            "CWE Description": "The product uses too much self-modifying code.",
            "Mapped CAPEC-ID": 486,
            "CAPEC Description": "An adversary may execute a flooding attack using the UDP protocol with the intent to deny legitimate users access to a service by consuming the available network bandwidth. Additionally, firewalls often open a port for each UDP connection destined for a service with an open UDP port, meaning the firewalls in essence save the connection state thus the high packet nature of a UDP flood can also overwhelm resources allocated to the firewall. UDP attacks can also target services like DNS or VoIP which utilize these protocols. Additionally, due to the session-less nature of the UDP protocol, the source of a packet is easily spoofed making it difficult to find the source of the attack.",
            "Original CWE-ID": "CWE-354",
            "Original CAPEC-ID": "145, 463, 75"
        },
        {
            "CVE-ID": "CVE-2023-52355",
            "CVE-Description": "An out-of-memory flaw was found in libtiff that could be triggered by passing a crafted tiff file to the TIFFRasterScanlineSize64() API. This flaw allows a remote attacker to cause a denial of service via a crafted input with a size smaller than 379 KB.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-52356",
            "CVE-Description": "A segment fault (SEGV) flaw was found in libtiff that could be triggered by passing a crafted tiff file to the TIFFReadRGBATileExt() API. This flaw allows a remote attacker to cause a heap-buffer overflow, leading to a denial of service.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2022-40090",
            "CVE-Description": "An issue was discovered in function TIFFReadDirectory libtiff before 4.4.0 allows attackers to cause a denial of service via crafted TIFF file.",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 1333,
            "CWE Description": "The product uses a regular expression with an inefficient, possibly exponential worst-case computational complexity that consumes excessive CPU cycles.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-835",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-25433",
            "CVE-Description": "libtiff 4.5.0 is vulnerable to Buffer Overflow via /libtiff/tools/tiffcrop.c:8499. Incorrect updating of buffer size after rotateImage() in tiffcrop cause heap-buffer-overflow and SEGV.",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 131,
            "CWE Description": "The product does not correctly calculate the size to be used when allocating a buffer, which could lead to a buffer overflow.",
            "Mapped CAPEC-ID": 44,
            "CAPEC Description": "An attack of this type exploits a buffer overflow vulnerability in the handling of binary resources. Binary resources may include music files like MP3, image files like JPEG files, and any other binary file. These attacks may pass unnoticed to the client machine through normal usage of files, such as a browser loading a seemingly innocent JPEG file. This can allow the adversary access to the execution stack and execute arbitrary code in the target process.",
            "Original CWE-ID": "CWE-120",
            "Original CAPEC-ID": "100, 92, 9, 14, 47, 24, 10, 44, 8, 67, 42, 45, 46"
        },
        {
            "CVE-ID": "CVE-2017-16232",
            "CVE-Description": "LibTIFF 4.0.8 has multiple memory leak vulnerabilities, which allow attackers to cause a denial of service (memory consumption), as demonstrated by tif_open.c, tif_lzw.c, and tif_aux.c. NOTE: Third parties were unable to reproduce the issue",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-772",
            "Original CAPEC-ID": "469"
        },
        {
            "CVE-ID": "CVE-2013-4392",
            "CVE-Description": "systemd, when updating file permissions, allows local users to change the permissions and SELinux security contexts for arbitrary files via a symlink attack on unspecified files.",
            "Severity": "LOW",
            "Mapped CWE-ID": 276,
            "CWE Description": "During installation, installed file permissions are set to allow anyone to modify those files.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2020-13529",
            "CVE-Description": "An exploitable denial-of-service vulnerability exists in Systemd 245. A specially crafted DHCP FORCERENEW packet can cause a server running the DHCP client to be vulnerable to a DHCP ACK spoofing attack. An attacker can forge a pair of FORCERENEW and DCHP ACK packets to reconfigure the server.",
            "Severity": "LOW",
            "Mapped CWE-ID": 290,
            "CWE Description": "This attack-focused weakness is caused by incorrectly implemented authentication schemes that are subject to spoofing attacks.",
            "Mapped CAPEC-ID": 126,
            "CAPEC Description": "An adversary uses path manipulation methods to exploit insufficient input validation of a target to obtain access to data that should be not be retrievable by ordinary well-formed requests. A typical variety of this attack involves specifying a path to a desired file together with dot-dot-slash characters, resulting in the file access API or function traversing out of the intended directory structure and into the root file system. By replacing or modifying the expected path information the access function or API retrieves the file desired by the attacker. These attacks either involve the attacker providing a complete path to a targeted file or using control characters (e.g. path separators (/ or ) and/or dots (.)) to reach desired directories or files.",
            "Original CWE-ID": "CWE-290",
            "Original CAPEC-ID": "459, 667, 60, 59, 476, 473, 94, 21, 22, 461"
        },
        {
            "CVE-ID": "CVE-2023-31437",
            "CVE-Description": "An issue was discovered in systemd 253. An attacker can modify a sealed log file such that, in some views, not all existing and sealed log messages are displayed. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
            "Severity": "LOW",
            "Mapped CWE-ID": 1123,
            "CWE Description": "The product uses too much self-modifying code.",
            "Mapped CAPEC-ID": 486,
            "CAPEC Description": "An adversary may execute a flooding attack using the UDP protocol with the intent to deny legitimate users access to a service by consuming the available network bandwidth. Additionally, firewalls often open a port for each UDP connection destined for a service with an open UDP port, meaning the firewalls in essence save the connection state thus the high packet nature of a UDP flood can also overwhelm resources allocated to the firewall. UDP attacks can also target services like DNS or VoIP which utilize these protocols. Additionally, due to the session-less nature of the UDP protocol, the source of a packet is easily spoofed making it difficult to find the source of the attack.",
            "Original CWE-ID": "CWE-354",
            "Original CAPEC-ID": "145, 463, 75"
        },
        {
            "CVE-ID": "CVE-2023-31438",
            "CVE-Description": "An issue was discovered in systemd 253. An attacker can truncate a sealed log file and then resume log sealing such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
            "Severity": "LOW",
            "Mapped CWE-ID": 649,
            "CWE Description": "The product uses obfuscation or encryption of inputs that should not be mutable by an external actor, but the product does not use integrity checks to detect if those inputs have been modified.",
            "Mapped CAPEC-ID": 331,
            "CAPEC Description": "An adversary sends a UDP packet to a closed port on the target machine to solicit an IP Header's total length field value within the echoed 'Port Unreachable error message. This type of behavior is useful for building a signature-base of operating system responses, particularly when error messages contain other types of information that is useful identifying specific operating system responses.",
            "Original CWE-ID": "CWE-354",
            "Original CAPEC-ID": "145, 463, 75"
        },
        {
            "CVE-ID": "CVE-2023-31439",
            "CVE-Description": "An issue was discovered in systemd 253. An attacker can modify the contents of past events in a sealed log file and then adjust the file such that checking the integrity shows no error, despite modifications. NOTE: the vendor reportedly sent \"a reply denying that any of the finding was a security vulnerability.\"",
            "Severity": "LOW",
            "Mapped CWE-ID": 1123,
            "CWE Description": "The product uses too much self-modifying code.",
            "Mapped CAPEC-ID": 486,
            "CAPEC Description": "An adversary may execute a flooding attack using the UDP protocol with the intent to deny legitimate users access to a service by consuming the available network bandwidth. Additionally, firewalls often open a port for each UDP connection destined for a service with an open UDP port, meaning the firewalls in essence save the connection state thus the high packet nature of a UDP flood can also overwhelm resources allocated to the firewall. UDP attacks can also target services like DNS or VoIP which utilize these protocols. Additionally, due to the session-less nature of the UDP protocol, the source of a packet is easily spoofed making it difficult to find the source of the attack.",
            "Original CWE-ID": "CWE-354",
            "Original CAPEC-ID": "145, 463, 75"
        },
        {
            "CVE-ID": "CVE-2022-0563",
            "CVE-Description": "A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 209,
            "CWE Description": "The product generates an error message that includes sensitive information about its environment, users, or associated data.",
            "Mapped CAPEC-ID": 87,
            "CAPEC Description": "An attacker employs forceful browsing (direct URL entry) to access portions of a website that are otherwise unreachable. Usually, a front controller or similar design pattern is employed to protect access to portions of a web application. Forceful browsing enables an attacker to access information, perform privileged operations and otherwise reach sections of the web application that have been improperly protected.",
            "Original CWE-ID": "CWE-209",
            "Original CAPEC-ID": "463, 215, 7, 54"
        },
        {
            "CVE-ID": "CVE-2022-43945",
            "CVE-Description": "The Linux kernel NFSD implementation prior to versions 5.19.17 and 6.0.2 are vulnerable to buffer overflow. NFSD tracks the number of pages held by each NFSD thread by combining the receive and send buffers of a remote procedure call (RPC) into a single array of pages. A client can force the send buffer to shrink by sending an RPC message over TCP with garbage data added at the end of the message. The RPC message with garbage data is still correctly formed according to the specification and is passed forward to handlers. Vulnerable code in NFSD is not expecting the oversized request and writes beyond the allocated buffer space. CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
            "Severity": "HIGH",
            "Mapped CWE-ID": 131,
            "CWE Description": "The product does not correctly calculate the size to be used when allocating a buffer, which could lead to a buffer overflow.",
            "Mapped CAPEC-ID": 44,
            "CAPEC Description": "An attack of this type exploits a buffer overflow vulnerability in the handling of binary resources. Binary resources may include music files like MP3, image files like JPEG files, and any other binary file. These attacks may pass unnoticed to the client machine through normal usage of files, such as a browser loading a seemingly innocent JPEG file. This can allow the adversary access to the execution stack and execute arbitrary code in the target process.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2024-26952",
            "CVE-Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nksmbd: fix potencial out-of-bounds when buffer offset is invalid\n\nI found potencial out-of-bounds when buffer offset fields of a few requests\nis invalid. This patch set the minimum value of buffer offset field to\n->Buffer offset to validate buffer length.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 67,
            "CAPEC Description": "This attack targets applications and software that uses the syslog() function insecurely. If an application does not explicitely use a format string parameter in a call to syslog(), user input can be placed in the format string parameter leading to a format string injection attack. Adversaries can then inject malicious format string commands into the function call leading to a buffer overflow. There are many reported software vulnerabilities with the root cause being a misuse of the syslog() function.",
            "Original CWE-ID": "CWE-120",
            "Original CAPEC-ID": "100, 92, 9, 14, 47, 24, 10, 44, 8, 67, 42, 45, 46"
        },
        {
            "CVE-ID": "CVE-2021-3669",
            "CVE-Description": "A flaw was found in the Linux kernel. Measuring usage of the shared memory does not scale with large shared memory segment counts which could lead to resource exhaustion and DoS.",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 126,
            "CAPEC Description": "An adversary uses path manipulation methods to exploit insufficient input validation of a target to obtain access to data that should be not be retrievable by ordinary well-formed requests. A typical variety of this attack involves specifying a path to a desired file together with dot-dot-slash characters, resulting in the file access API or function traversing out of the intended directory structure and into the root file system. By replacing or modifying the expected path information the access function or API retrieves the file desired by the attacker. These attacks either involve the attacker providing a complete path to a targeted file or using control characters (e.g. path separators (/ or ) and/or dots (.)) to reach desired directories or files.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2022-0480",
            "CVE-Description": "A flaw was found in the filelock_init in fs/locks.c function in the Linux kernel. This issue can lead to host memory exhaustion due to memcg not limiting the number of Portable Operating System Interface (POSIX) file locks.",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 770,
            "CWE Description": "The product allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on the size or number of resources that can be allocated, in violation of the intended security policy for that actor.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-770",
            "Original CAPEC-ID": "487, 528, 130, 496, 495, 494, 493, 491, 147, 229, 489, 469, 482, 488, 486, 490, 125, 197, 230, 231"
        },
        {
            "CVE-ID": "CVE-2024-36938",
            "CVE-Description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf, skmsg: Fix NULL pointer dereference in sk_psock_skb_ingress_enqueue\n\nFix NULL pointer data-races in sk_psock_skb_ingress_enqueue() which\nsyzbot reported [1].\n\n[1]\nBUG: KCSAN: data-race in sk_psock_drop / sk_psock_skb_ingress_enqueue\n\nwrite to 0xffff88814b3278b8 of 8 bytes by task 10724 on cpu 1:\n sk_psock_stop_verdict net/core/skmsg.c:1257 [inline]\n sk_psock_drop+0x13e/0x1f0 net/core/skmsg.c:843\n sk_psock_put include/linux/skmsg.h:459 [inline]\n sock_map_close+0x1a7/0x260 net/core/sock_map.c:1648\n unix_release+0x4b/0x80 net/unix/af_unix.c:1048\n __sock_release net/socket.c:659 [inline]\n sock_close+0x68/0x150 net/socket.c:1421\n __fput+0x2c1/0x660 fs/file_table.c:422\n __fput_sync+0x44/0x60 fs/file_table.c:507\n __do_sys_close fs/open.c:1556 [inline]\n __se_sys_close+0x101/0x1b0 fs/open.c:1541\n __x64_sys_close+0x1f/0x30 fs/open.c:1541\n do_syscall_64+0xd3/0x1d0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\nread to 0xffff88814b3278b8 of 8 bytes by task 10713 on cpu 0:\n sk_psock_data_ready include/linux/skmsg.h:464 [inline]\n sk_psock_skb_ingress_enqueue+0x32d/0x390 net/core/skmsg.c:555\n sk_psock_skb_ingress_self+0x185/0x1e0 net/core/skmsg.c:606\n sk_psock_verdict_apply net/core/skmsg.c:1008 [inline]\n sk_psock_verdict_recv+0x3e4/0x4a0 net/core/skmsg.c:1202\n unix_read_skb net/unix/af_unix.c:2546 [inline]\n unix_stream_read_skb+0x9e/0xf0 net/unix/af_unix.c:2682\n sk_psock_verdict_data_ready+0x77/0x220 net/core/skmsg.c:1223\n unix_stream_sendmsg+0x527/0x860 net/unix/af_unix.c:2339\n sock_sendmsg_nosec net/socket.c:730 [inline]\n __sock_sendmsg+0x140/0x180 net/socket.c:745\n ____sys_sendmsg+0x312/0x410 net/socket.c:2584\n ___sys_sendmsg net/socket.c:2638 [inline]\n __sys_sendmsg+0x1e9/0x280 net/socket.c:2667\n __do_sys_sendmsg net/socket.c:2676 [inline]\n __se_sys_sendmsg net/socket.c:2674 [inline]\n __x64_sys_sendmsg+0x46/0x50 net/socket.c:2674\n do_syscall_64+0xd3/0x1d0\n entry_SYSCALL_64_after_hwframe+0x6d/0x75\n\nvalue changed: 0xffffffff83d7feb0 -> 0x0000000000000000\n\nReported by Kernel Concurrency Sanitizer on:\nCPU: 0 PID: 10713 Comm: syz-executor.4 Tainted: G        W          6.8.0-syzkaller-08951-gfe46a7dd189e #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 02/29/2024\n\nPrior to this, commit 4cd12c6065df (\"bpf, sockmap: Fix NULL pointer\ndereference in sk_psock_verdict_data_ready()\") fixed one NULL pointer\nsimilarly due to no protection of saved_data_ready. Here is another\ndifferent caller causing the same issue because of the same reason. So\nwe should protect it with sk_callback_lock read lock because the writer\nside in the sk_psock_drop() uses \"write_lock_bh(&sk->sk_callback_lock);\".\n\nTo avoid errors that could happen in future, I move those two pairs of\nlock into the sk_psock_data_ready(), which is suggested by John Fastabend.",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 15,
            "CWE Description": "One or more system settings or configuration elements can be externally controlled by a user.",
            "Mapped CAPEC-ID": 1,
            "CAPEC Description": "In applications, particularly web applications, access to functionality is mitigated by an authorization framework. This framework maps Access Control Lists (ACLs) to elements of the application's functionality; particularly URL's for web apps. In the case that the administrator failed to specify an ACL for a particular element, an attacker may be able to access it with impunity. An attacker with the ability to access functionality not properly constrained by ACLs can obtain sensitive information and possibly compromise the entire application. Such an attacker can access resources that must be available only to users at a higher privilege level, can access management sections of the application, or can run queries for data that they otherwise not supposed to.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2018-12928",
            "CVE-Description": "In the Linux kernel 4.15.0, a NULL pointer dereference was discovered in hfs_ext_read_extent in hfs.ko. This can occur during a mount of a crafted hfs filesystem.",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2019-12378",
            "CVE-Description": "An issue was discovered in ip6_ra_control in net/ipv6/ipv6_sockglue.c in the Linux kernel through 5.1.5. There is an unchecked kmalloc of new_ra, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: This has been disputed as not an issue",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 26,
            "CAPEC Description": "The adversary targets a race condition occurring when multiple processes access and manipulate the same resource concurrently, and the outcome of the execution depends on the particular order in which the access takes place. The adversary can leverage a race condition by running the race, modifying the resource and modifying the normal execution flow. For instance, a race condition can occur while accessing a file: the adversary can trick the system by replacing the original file with their version and cause the system to read the malicious file.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2019-12381",
            "CVE-Description": "An issue was discovered in ip_ra_control in net/ipv4/ip_sockglue.c in the Linux kernel through 5.1.5. There is an unchecked kmalloc of new_ra, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: this is disputed because new_ra is never used if it is NULL",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 67,
            "CAPEC Description": "This attack targets applications and software that uses the syslog() function insecurely. If an application does not explicitely use a format string parameter in a call to syslog(), user input can be placed in the format string parameter leading to a format string injection attack. Adversaries can then inject malicious format string commands into the function call leading to a buffer overflow. There are many reported software vulnerabilities with the root cause being a misuse of the syslog() function.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2019-12382",
            "CVE-Description": "An issue was discovered in drm_load_edid_firmware in drivers/gpu/drm/drm_edid_load.c in the Linux kernel through 5.1.5. There is an unchecked kstrdup of fwstr, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: The vendor disputes this issues as not being a vulnerability because kstrdup() returning NULL is handled sufficiently and there is no chance for a NULL pointer dereference",
            "Severity": "LOW",
            "Mapped CWE-ID": 822,
            "CWE Description": "The product obtains a value from an untrusted source, converts this value to a pointer, and dereferences the resulting pointer.",
            "Mapped CAPEC-ID": 488,
            "CAPEC Description": "An adversary may execute a flooding attack using the HTTP protocol with the intent to deny legitimate users access to a service by consuming resources at the application layer such as web services and their infrastructure. These attacks use legitimate session-based HTTP GET requests designed to consume large amounts of a server's resources. Since these are legitimate sessions this attack is very difficult to detect.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2019-12455",
            "CVE-Description": "An issue was discovered in sunxi_divs_clk_setup in drivers/clk/sunxi/clk-sunxi.c in the Linux kernel through 5.1.5. There is an unchecked kstrndup of derived_name, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash). NOTE: This id is disputed as not being an issue because \u201cThe memory allocation that was not checked is part of a code that only runs at boot time, before user processes are started. Therefore, there is no possibility for an unprivileged user to control it, and no denial of service.\u201d",
            "Severity": "LOW",
            "Mapped CWE-ID": 825,
            "CWE Description": "The product dereferences a pointer that contains a location for memory that was previously valid, but is no longer valid.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2019-16229",
            "CVE-Description": "drivers/gpu/drm/amd/amdkfd/kfd_interrupt.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference. NOTE: The security community disputes this issues as not being serious enough to be deserving a CVE id",
            "Severity": "LOW",
            "Mapped CWE-ID": 252,
            "CWE Description": "The product does not check the return value from a method or function, which can prevent it from detecting unexpected states and conditions.",
            "Mapped CAPEC-ID": 83,
            "CAPEC Description": "An attacker can craft special user-controllable input consisting of XPath expressions to inject the XML database and bypass authentication or glean information that they normally would not be able to. XPath Injection enables an attacker to talk directly to the XML database, thus bypassing the application completely. XPath Injection results from the failure of an application to properly sanitize input used as part of dynamic XPath expressions used to query an XML database.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2019-16230",
            "CVE-Description": "drivers/gpu/drm/radeon/radeon_display.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference. NOTE: A third-party software maintainer states that the work queue allocation is happening during device initialization, which for a graphics card occurs during boot. It is not attacker controllable and OOM at that time is highly unlikely",
            "Severity": "LOW",
            "Mapped CWE-ID": 170,
            "CWE Description": "The product does not terminate or incorrectly terminates a string or array with a null character or equivalent terminator.",
            "Mapped CAPEC-ID": 67,
            "CAPEC Description": "This attack targets applications and software that uses the syslog() function insecurely. If an application does not explicitely use a format string parameter in a call to syslog(), user input can be placed in the format string parameter leading to a format string injection attack. Adversaries can then inject malicious format string commands into the function call leading to a buffer overflow. There are many reported software vulnerabilities with the root cause being a misuse of the syslog() function.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2019-16231",
            "CVE-Description": "drivers/net/fjes/fjes_main.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2019-16232",
            "CVE-Description": "drivers/net/wireless/marvell/libertas/if_sdio.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.",
            "Severity": "LOW",
            "Mapped CWE-ID": 253,
            "CWE Description": "The product incorrectly checks a return value from a function, which prevents it from detecting errors or exceptional conditions.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2019-16233",
            "CVE-Description": "drivers/scsi/qla2xxx/qla_os.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.",
            "Severity": "LOW",
            "Mapped CWE-ID": 252,
            "CWE Description": "The product does not check the return value from a method or function, which can prevent it from detecting unexpected states and conditions.",
            "Mapped CAPEC-ID": 77,
            "CAPEC Description": "This attack targets user controlled variables (DEBUG=1, PHP Globals, and So Forth). An adversary can override variables leveraging user-supplied, untrusted query variables directly used on the application server without any data sanitization. In extreme cases, the adversary can change variables controlling the business logic of the application. For instance, in languages like PHP, a number of poorly set default configurations may allow the user to override variables.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2019-16234",
            "CVE-Description": "drivers/net/wireless/intel/iwlwifi/pcie/trans.c in the Linux kernel 5.2.14 does not check the alloc_workqueue return value, leading to a NULL pointer dereference.",
            "Severity": "LOW",
            "Mapped CWE-ID": 253,
            "CWE Description": "The product incorrectly checks a return value from a function, which prevents it from detecting errors or exceptional conditions.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2019-19378",
            "CVE-Description": "In the Linux kernel 5.0.21, mounting a crafted btrfs filesystem image can lead to slab-out-of-bounds write access in index_rbio_pages in fs/btrfs/raid56.c.",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-32078",
            "CVE-Description": "An Out-of-Bounds Read was discovered in arch/arm/mach-footbridge/personal-pci.c in the Linux kernel through 5.12.11 because of the lack of a check for a value that shouldn't be negative, e.g., access to element -2 of an array, aka CID-298a58e165e4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 805,
            "CWE Description": "The product uses a sequential operation to read or write a buffer, but it uses an incorrect length value that causes it to access memory that is outside of the bounds of the buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2023-1075",
            "CVE-Description": "A flaw was found in the Linux Kernel. The tls_is_tx_ready() incorrectly checks for list emptiness, potentially accessing a type confused entry to the list_head, leaking the last byte of the confused field that overlaps with rec->tx_ready.",
            "Severity": "LOW",
            "Mapped CWE-ID": 1287,
            "CWE Description": "The product receives input that is expected to be of a certain type, but it does not validate or incorrectly validates that the input is actually of the expected type.",
            "Mapped CAPEC-ID": 469,
            "CAPEC Description": "An attacker performs flooding at the HTTP level to bring down only a particular web application rather than anything listening on a TCP/IP connection. This denial of service attack requires substantially fewer packets to be sent which makes DoS harder to detect. This is an equivalent of SYN flood in HTTP. The idea is to keep the HTTP session alive indefinitely and then repeat that hundreds of times. This attack targets resource depletion weaknesses in web server software. The web server will wait to attacker's responses on the initiated HTTP sessions while the connection threads are being exhausted.",
            "Original CWE-ID": "CWE-843",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-23003",
            "CVE-Description": "In the Linux kernel before 5.16, tools/perf/util/expr.c lacks a check for the hashmap__new return value.",
            "Severity": "LOW",
            "Mapped CWE-ID": 252,
            "CWE Description": "The product does not check the return value from a method or function, which can prevent it from detecting unexpected states and conditions.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-252",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-26242",
            "CVE-Description": "afu_mmio_region_get_by_offset in drivers/fpga/dfl-afu-region.c in the Linux kernel through 6.1.12 has an integer overflow.",
            "Severity": "LOW",
            "Mapped CWE-ID": 191,
            "CWE Description": "The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2023-31081",
            "CVE-Description": "An issue was discovered in drivers/media/test-drivers/vidtv/vidtv_bridge.c in the Linux kernel 6.2. There is a NULL pointer dereference in vidtv_mux_stop_thread. In vidtv_stop_streaming, after dvb->mux=NULL occurs, it executes vidtv_mux_stop_thread(dvb->mux).",
            "Severity": "LOW",
            "Mapped CWE-ID": 476,
            "CWE Description": "A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.",
            "Mapped CAPEC-ID": 67,
            "CAPEC Description": "This attack targets applications and software that uses the syslog() function insecurely. If an application does not explicitely use a format string parameter in a call to syslog(), user input can be placed in the format string parameter leading to a format string injection attack. Adversaries can then inject malicious format string commands into the function call leading to a buffer overflow. There are many reported software vulnerabilities with the root cause being a misuse of the syslog() function.",
            "Original CWE-ID": "CWE-476",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2023-6610",
            "CVE-Description": "An out-of-bounds read vulnerability was found in smb2_dump_detail in fs/smb/client/smb2ops.c in the Linux Kernel. This issue could allow a local attacker to crash the system or leak internal kernel information.",
            "Severity": "LOW",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 540,
            "CAPEC Description": "An adversary attacks a target by providing input that causes an application to read beyond the boundary of a defined buffer. This typically occurs when a value influencing where to start or stop reading is set to reflect positions outside of the valid memory location of the buffer. This type of attack may result in exposure of sensitive information, a system crash, or arbitrary code execution.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2013-4235",
            "CVE-Description": "shadow: TOCTOU (time-of-check time-of-use) race condition when copying and removing directory trees",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 126,
            "CAPEC Description": "An adversary uses path manipulation methods to exploit insufficient input validation of a target to obtain access to data that should be not be retrievable by ordinary well-formed requests. A typical variety of this attack involves specifying a path to a desired file together with dot-dot-slash characters, resulting in the file access API or function traversing out of the intended directory structure and into the root file system. By replacing or modifying the expected path information the access function or API retrieves the file desired by the attacker. These attacks either involve the attacker providing a complete path to a targeted file or using control characters (e.g. path separators (/ or ) and/or dots (.)) to reach desired directories or files.",
            "Original CWE-ID": "CWE-367",
            "Original CAPEC-ID": "27, 29"
        },
        {
            "CVE-ID": "CVE-2022-1304",
            "CVE-Description": "An out-of-bounds read/write vulnerability was found in e2fsprogs 1.46.5. This issue leads to a segmentation fault and possibly arbitrary code execution via a specially crafted filesystem.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 125,
            "CWE Description": "The product reads data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 77,
            "CAPEC Description": "This attack targets user controlled variables (DEBUG=1, PHP Globals, and So Forth). An adversary can override variables leveraging user-supplied, untrusted query variables directly used on the application server without any data sanitization. In extreme cases, the adversary can change variables controlling the business logic of the application. For instance, in languages like PHP, a number of poorly set default configurations may allow the user to override variables.",
            "Original CWE-ID": "CWE-125",
            "Original CAPEC-ID": "540"
        },
        {
            "CVE-ID": "CVE-2022-0563",
            "CVE-Description": "A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 209,
            "CWE Description": "The product generates an error message that includes sensitive information about its environment, users, or associated data.",
            "Mapped CAPEC-ID": 87,
            "CAPEC Description": "An attacker employs forceful browsing (direct URL entry) to access portions of a website that are otherwise unreachable. Usually, a front controller or similar design pattern is employed to protect access to portions of a web application. Forceful browsing enables an attacker to access information, perform privileged operations and otherwise reach sections of the web application that have been improperly protected.",
            "Original CWE-ID": "CWE-209",
            "Original CAPEC-ID": "463, 215, 7, 54"
        },
        {
            "CVE-ID": "CVE-2013-4235",
            "CVE-Description": "shadow: TOCTOU (time-of-check time-of-use) race condition when copying and removing directory trees",
            "Severity": "LOW",
            "Mapped CWE-ID": 787,
            "CWE Description": "The product writes data past the end, or before the beginning, of the intended buffer.",
            "Mapped CAPEC-ID": 126,
            "CAPEC Description": "An adversary uses path manipulation methods to exploit insufficient input validation of a target to obtain access to data that should be not be retrievable by ordinary well-formed requests. A typical variety of this attack involves specifying a path to a desired file together with dot-dot-slash characters, resulting in the file access API or function traversing out of the intended directory structure and into the root file system. By replacing or modifying the expected path information the access function or API retrieves the file desired by the attacker. These attacks either involve the attacker providing a complete path to a targeted file or using control characters (e.g. path separators (/ or ) and/or dots (.)) to reach desired directories or files.",
            "Original CWE-ID": "CWE-367",
            "Original CAPEC-ID": "27, 29"
        },
        {
            "CVE-ID": "CVE-2020-16156",
            "CVE-Description": "CPAN 2.28 allows Signature Verification Bypass.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 303,
            "CWE Description": "The requirements for the product dictate the use of an established authentication algorithm, but the implementation of the algorithm is incorrect.",
            "Mapped CAPEC-ID": 528,
            "CAPEC Description": "An adversary may execute a flooding attack using XML messages with the intent to deny legitimate users access to a web service. These attacks are accomplished by sending a large number of XML based requests and letting the service attempt to parse each one. In many cases this type of an attack will result in a XML Denial of Service (XDoS) due to an application becoming unstable, freezing, or crashing.",
            "Original CWE-ID": "CWE-347",
            "Original CAPEC-ID": "475, 463"
        },
        {
            "CVE-ID": "CVE-2023-31484",
            "CVE-Description": "CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 295,
            "CWE Description": "The product does not validate, or incorrectly validates, a certificate.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-295",
            "Original CAPEC-ID": "475, 459"
        },
        {
            "CVE-ID": "CVE-2023-47038",
            "CVE-Description": "A vulnerability was found in perl 5.30.0 through 5.38.0. This issue occurs when a crafted regular expression is compiled by perl, which can allow an attacker controlled byte buffer overflow in a heap allocated buffer.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2011-4116",
            "CVE-Description": "_is_safe in the File::Temp module for Perl does not properly handle symlinks.",
            "Severity": "LOW",
            "Mapped CWE-ID": 1333,
            "CWE Description": "The product uses a regular expression with an inefficient, possibly exponential worst-case computational complexity that consumes excessive CPU cycles.",
            "Mapped CAPEC-ID": 528,
            "CAPEC Description": "An adversary may execute a flooding attack using XML messages with the intent to deny legitimate users access to a web service. These attacks are accomplished by sending a large number of XML based requests and letting the service attempt to parse each one. In many cases this type of an attack will result in a XML Denial of Service (XDoS) due to an application becoming unstable, freezing, or crashing.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2023-31486",
            "CVE-Description": "HTTP::Tiny before 0.083, a Perl core module since 5.13.9 and available standalone on CPAN, has an insecure default TLS configuration where users must opt in to verify certificates.",
            "Severity": "LOW",
            "Mapped CWE-ID": 1392,
            "CWE Description": "The product uses default credentials (such as passwords or cryptographic keys) for potentially critical functionality.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-295",
            "Original CAPEC-ID": "475, 459"
        },
        {
            "CVE-ID": "CVE-2020-16156",
            "CVE-Description": "CPAN 2.28 allows Signature Verification Bypass.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 303,
            "CWE Description": "The requirements for the product dictate the use of an established authentication algorithm, but the implementation of the algorithm is incorrect.",
            "Mapped CAPEC-ID": 528,
            "CAPEC Description": "An adversary may execute a flooding attack using XML messages with the intent to deny legitimate users access to a web service. These attacks are accomplished by sending a large number of XML based requests and letting the service attempt to parse each one. In many cases this type of an attack will result in a XML Denial of Service (XDoS) due to an application becoming unstable, freezing, or crashing.",
            "Original CWE-ID": "CWE-347",
            "Original CAPEC-ID": "475, 463"
        },
        {
            "CVE-ID": "CVE-2023-31484",
            "CVE-Description": "CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 295,
            "CWE Description": "The product does not validate, or incorrectly validates, a certificate.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-295",
            "Original CAPEC-ID": "475, 459"
        },
        {
            "CVE-ID": "CVE-2023-47038",
            "CVE-Description": "A vulnerability was found in perl 5.30.0 through 5.38.0. This issue occurs when a crafted regular expression is compiled by perl, which can allow an attacker controlled byte buffer overflow in a heap allocated buffer.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2011-4116",
            "CVE-Description": "_is_safe in the File::Temp module for Perl does not properly handle symlinks.",
            "Severity": "LOW",
            "Mapped CWE-ID": 1333,
            "CWE Description": "The product uses a regular expression with an inefficient, possibly exponential worst-case computational complexity that consumes excessive CPU cycles.",
            "Mapped CAPEC-ID": 528,
            "CAPEC Description": "An adversary may execute a flooding attack using XML messages with the intent to deny legitimate users access to a web service. These attacks are accomplished by sending a large number of XML based requests and letting the service attempt to parse each one. In many cases this type of an attack will result in a XML Denial of Service (XDoS) due to an application becoming unstable, freezing, or crashing.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2023-31486",
            "CVE-Description": "HTTP::Tiny before 0.083, a Perl core module since 5.13.9 and available standalone on CPAN, has an insecure default TLS configuration where users must opt in to verify certificates.",
            "Severity": "LOW",
            "Mapped CWE-ID": 1392,
            "CWE Description": "The product uses default credentials (such as passwords or cryptographic keys) for potentially critical functionality.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-295",
            "Original CAPEC-ID": "475, 459"
        },
        {
            "CVE-ID": "CVE-2020-16156",
            "CVE-Description": "CPAN 2.28 allows Signature Verification Bypass.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 303,
            "CWE Description": "The requirements for the product dictate the use of an established authentication algorithm, but the implementation of the algorithm is incorrect.",
            "Mapped CAPEC-ID": 528,
            "CAPEC Description": "An adversary may execute a flooding attack using XML messages with the intent to deny legitimate users access to a web service. These attacks are accomplished by sending a large number of XML based requests and letting the service attempt to parse each one. In many cases this type of an attack will result in a XML Denial of Service (XDoS) due to an application becoming unstable, freezing, or crashing.",
            "Original CWE-ID": "CWE-347",
            "Original CAPEC-ID": "475, 463"
        },
        {
            "CVE-ID": "CVE-2023-31484",
            "CVE-Description": "CPAN.pm before 2.35 does not verify TLS certificates when downloading distributions over HTTPS.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 295,
            "CWE Description": "The product does not validate, or incorrectly validates, a certificate.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-295",
            "Original CAPEC-ID": "475, 459"
        },
        {
            "CVE-ID": "CVE-2023-47038",
            "CVE-Description": "A vulnerability was found in perl 5.30.0 through 5.38.0. This issue occurs when a crafted regular expression is compiled by perl, which can allow an attacker controlled byte buffer overflow in a heap allocated buffer.",
            "Severity": "HIGH",
            "Mapped CWE-ID": 120,
            "CWE Description": "The product copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2011-4116",
            "CVE-Description": "_is_safe in the File::Temp module for Perl does not properly handle symlinks.",
            "Severity": "LOW",
            "Mapped CWE-ID": 1333,
            "CWE Description": "The product uses a regular expression with an inefficient, possibly exponential worst-case computational complexity that consumes excessive CPU cycles.",
            "Mapped CAPEC-ID": 528,
            "CAPEC Description": "An adversary may execute a flooding attack using XML messages with the intent to deny legitimate users access to a web service. These attacks are accomplished by sending a large number of XML based requests and letting the service attempt to parse each one. In many cases this type of an attack will result in a XML Denial of Service (XDoS) due to an application becoming unstable, freezing, or crashing.",
            "Original CWE-ID": "CWE-59",
            "Original CAPEC-ID": "76, 17, 35, 132"
        },
        {
            "CVE-ID": "CVE-2023-31486",
            "CVE-Description": "HTTP::Tiny before 0.083, a Perl core module since 5.13.9 and available standalone on CPAN, has an insecure default TLS configuration where users must opt in to verify certificates.",
            "Severity": "LOW",
            "Mapped CWE-ID": 1392,
            "CWE Description": "The product uses default credentials (such as passwords or cryptographic keys) for potentially critical functionality.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-295",
            "Original CAPEC-ID": "475, 459"
        },
        {
            "CVE-ID": "CVE-2023-4016",
            "CVE-Description": "Under some circumstances, this weakness allows a user who has access to run the \u201cps\u201d utility on a machine, the ability to write almost unlimited amounts of unfiltered data into the process heap.",
            "Severity": "LOW",
            "Mapped CWE-ID": 306,
            "CWE Description": "The product does not perform any authentication for functionality that requires a provable user identity or consumes a significant amount of resources.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-787",
            "Original CAPEC-ID": "N/A"
        },
        {
            "CVE-ID": "CVE-2021-28861",
            "CVE-Description": "Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states \"Warning: http.server is not recommended for production. It only implements basic security checks.\"",
            "Severity": "LOW",
            "Mapped CWE-ID": 601,
            "CWE Description": "A web application accepts a user-controlled input that specifies a link to an external site, and uses that link in a Redirect. This simplifies phishing attacks.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-601",
            "Original CAPEC-ID": "178"
        },
        {
            "CVE-ID": "CVE-2022-37454",
            "CVE-Description": "The Keccak XKCP SHA-3 reference implementation before fdc6fef has an integer overflow and resultant buffer overflow that allows attackers to execute arbitrary code or eliminate expected cryptographic properties. This occurs in the sponge function interface.",
            "Severity": "LOW",
            "Mapped CWE-ID": 191,
            "CWE Description": "The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2021-28861",
            "CVE-Description": "Python 3.x through 3.10 has an open redirection vulnerability in lib/http/server.py due to no protection against multiple (/) at the beginning of URI path which may leads to information disclosure. NOTE: this is disputed by a third party because the http.server.html documentation page states \"Warning: http.server is not recommended for production. It only implements basic security checks.\"",
            "Severity": "LOW",
            "Mapped CWE-ID": 601,
            "CWE Description": "A web application accepts a user-controlled input that specifies a link to an external site, and uses that link in a Redirect. This simplifies phishing attacks.",
            "Mapped CAPEC-ID": 109,
            "CAPEC Description": "An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject their own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.",
            "Original CWE-ID": "CWE-601",
            "Original CAPEC-ID": "178"
        },
        {
            "CVE-ID": "CVE-2022-37454",
            "CVE-Description": "The Keccak XKCP SHA-3 reference implementation before fdc6fef has an integer overflow and resultant buffer overflow that allows attackers to execute arbitrary code or eliminate expected cryptographic properties. This occurs in the sponge function interface.",
            "Severity": "LOW",
            "Mapped CWE-ID": 191,
            "CWE Description": "The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.",
            "Mapped CAPEC-ID": 92,
            "CAPEC Description": "This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.",
            "Original CWE-ID": "CWE-190",
            "Original CAPEC-ID": "92"
        },
        {
            "CVE-ID": "CVE-2022-0563",
            "CVE-Description": "A flaw was found in the util-linux chfn and chsh utilities when compiled with Readline support. The Readline library uses an \"INPUTRC\" environment variable to get a path to the library config file. When the library cannot parse the specified file, it prints an error message containing data from the file. This flaw allows an unprivileged user to read root-owned files, potentially leading to privilege escalation. This flaw affects util-linux versions prior to 2.37.4.",
            "Severity": "LOW",
            "Mapped CWE-ID": 209,
            "CWE Description": "The product generates an error message that includes sensitive information about its environment, users, or associated data.",
            "Mapped CAPEC-ID": 87,
            "CAPEC Description": "An attacker employs forceful browsing (direct URL entry) to access portions of a website that are otherwise unreachable. Usually, a front controller or similar design pattern is employed to protect access to portions of a web application. Forceful browsing enables an attacker to access information, perform privileged operations and otherwise reach sections of the web application that have been improperly protected.",
            "Original CWE-ID": "CWE-209",
            "Original CAPEC-ID": "463, 215, 7, 54"
        },
        {
            "CVE-ID": "CVE-2023-28859",
            "CVE-Description": "redis-py before 4.4.4 and 4.5.x before 4.5.4 leaves a connection open after canceling an async Redis command at an inopportune time, and can send response data to the client of an unrelated request. (This could, for example, happen for a non-pipeline operation.) NOTE: the solutions for CVE-2023-28859 address data leakage across AsyncIO connections in general.",
            "Severity": "MEDIUM",
            "Mapped CWE-ID": 78,
            "CWE Description": "The product constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.",
            "Mapped CAPEC-ID": 67,
            "CAPEC Description": "This attack targets applications and software that uses the syslog() function insecurely. If an application does not explicitely use a format string parameter in a call to syslog(), user input can be placed in the format string parameter leading to a format string injection attack. Adversaries can then inject malicious format string commands into the function call leading to a buffer overflow. There are many reported software vulnerabilities with the root cause being a misuse of the syslog() function.",
            "Original CWE-ID": "CWE-459",
            "Original CAPEC-ID": "N/A"
        }
    ],
    "statistics": {
        "severity_accuracy": {
            "LOW": 0.53125,
            "MEDIUM": 0.3333333333333333,
            "HIGH": 0.4642857142857143,
            "CRITICAL": 0.0
        },
        "overall_accuracy": 0.5093632958801498,
        "non_2023_accuracy": 0.467005076142132,
        "severity_count": {
            "LOW": 224,
            "MEDIUM": 12,
            "HIGH": 28,
            "CRITICAL": 3
        },
        "capec_accuracy": 0.2949640287769784
    }
}